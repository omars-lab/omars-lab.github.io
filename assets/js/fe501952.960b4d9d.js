"use strict";(self.webpackChunkbytesofpurpose_blog=self.webpackChunkbytesofpurpose_blog||[]).push([[1360],{28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>t});var s=r(96540);const i={},o=s.createContext(i);function l(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(o.Provider,{value:n},e.children)}},33783:e=>{e.exports=JSON.parse('{"permalink":"/blog/dfs-vs-bfs","editUrl":"https://github.com/omars-lab/omars-lab.github.io/edit/master/bytesofpurpose-blog/blog/blog/2025-03-07-DFS-vs-BFS.md","source":"@site/blog/2025-03-07-DFS-vs-BFS.md","title":"DFS vs BFS: When to Use Each Algorithm for Graph Problems","description":"Learn the key differences between Depth-First Search and Breadth-First Search, and discover when to use each algorithm for optimal problem-solving.","date":"2025-03-07T10:00:00.000Z","tags":[{"inline":true,"label":"dfs","permalink":"/blog/tags/dfs"},{"inline":true,"label":"bfs","permalink":"/blog/tags/bfs"},{"inline":true,"label":"graph-theory","permalink":"/blog/tags/graph-theory"},{"inline":true,"label":"algorithms","permalink":"/blog/tags/algorithms"},{"inline":true,"label":"leetcode","permalink":"/blog/tags/leetcode"}],"readingTime":4.74,"hasTruncateMarker":false,"authors":[{"name":"Omar Eid","title":"Senior Software Engineer & Entrepreneur","url":"https://github.com/omars-lab","imageURL":"https://github.com/omars-lab.png","key":"oeid","page":null}],"frontMatter":{"slug":"dfs-vs-bfs","title":"DFS vs BFS: When to Use Each Algorithm for Graph Problems","description":"Learn the key differences between Depth-First Search and Breadth-First Search, and discover when to use each algorithm for optimal problem-solving.","authors":["oeid"],"tags":["dfs","bfs","graph-theory","algorithms","leetcode"],"date":"2025-03-07T10:00","draft":false},"unlisted":false,"nextItem":{"title":"Docs vs Blog Posts: When to Choose Each Format","permalink":"/blog/docs-vs-blog-posts"}}')},33827:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>c,frontMatter:()=>l,metadata:()=>s,toc:()=>a});var s=r(33783),i=r(74848),o=r(28453);const l={slug:"dfs-vs-bfs",title:"DFS vs BFS: When to Use Each Algorithm for Graph Problems",description:"Learn the key differences between Depth-First Search and Breadth-First Search, and discover when to use each algorithm for optimal problem-solving.",authors:["oeid"],tags:["dfs","bfs","graph-theory","algorithms","leetcode"],date:"2025-03-07T10:00",draft:!1},t="DFS vs BFS: When to Use Each Algorithm for Graph Problems",d={authorsImageUrls:[void 0]},a=[{value:"The Core Difference",id:"the-core-difference",level:2},{value:"When to Use BFS",id:"when-to-use-bfs",level:2},{value:"\u2705 Use BFS when you need:",id:"-use-bfs-when-you-need",level:3},{value:"BFS Examples:",id:"bfs-examples",level:3},{value:"When to Use DFS",id:"when-to-use-dfs",level:2},{value:"\u2705 Use DFS when you need:",id:"-use-dfs-when-you-need",level:3},{value:"DFS Examples:",id:"dfs-examples",level:3},{value:"Decision Framework",id:"decision-framework",level:2},{value:"Ask yourself these questions:",id:"ask-yourself-these-questions",level:3},{value:"Real-World Problem: Word Ladder",id:"real-world-problem-word-ladder",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Time Complexity:",id:"time-complexity",level:3},{value:"Space Complexity:",id:"space-complexity",level:3},{value:"Common Mistakes to Avoid",id:"common-mistakes-to-avoid",level:2},{value:"Practice Problems",id:"practice-problems",level:2},{value:"BFS Problems:",id:"bfs-problems",level:3},{value:"DFS Problems:",id:"dfs-problems",level:3},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"When solving graph and tree problems, one of the most fundamental decisions you'll make is choosing between Depth-First Search (DFS) and Breadth-First Search (BFS). Understanding when to use each algorithm can be the difference between an elegant solution and a complex workaround."}),"\n",(0,i.jsx)(n.h2,{id:"the-core-difference",children:"The Core Difference"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Depth-First Search (DFS)"})," explores as far as possible along each branch before backtracking. It's like exploring a maze by always taking the first available path until you hit a dead end."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Breadth-First Search (BFS)"})," explores all nodes at the current level before moving to the next level. It's like exploring a maze by checking all paths one step away, then all paths two steps away, and so on."]}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-bfs",children:"When to Use BFS"}),"\n",(0,i.jsx)(n.h3,{id:"-use-bfs-when-you-need",children:"\u2705 Use BFS when you need:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Shortest Path Problems"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Finding the shortest path in an unweighted graph"}),"\n",(0,i.jsx)(n.li,{children:"Minimum steps to reach a target"}),"\n",(0,i.jsx)(n.li,{children:"Level-by-level exploration"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Level-Based Operations"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Grouping nodes by their distance from the root"}),"\n",(0,i.jsx)(n.li,{children:"Processing nodes level by level"}),"\n",(0,i.jsx)(n.li,{children:"Finding nodes at a specific distance"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Tree Comparison"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Comparing two trees structure"}),"\n",(0,i.jsx)(n.li,{children:"Checking if trees are identical or symmetric"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"bfs-examples",children:"BFS Examples:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Level Order Traversal:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def level_order_traversal(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = [root]\n    \n    while queue:\n        level_size = len(queue)\n        level = []\n        \n        for _ in range(level_size):\n            node = queue.pop(0)\n            level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(level)\n    \n    return result\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Tree Comparison:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def is_same_tree(p, q):\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    \n    queue = [(p, q)]\n    \n    while queue:\n        node1, node2 = queue.pop(0)\n        \n        if node1.val != node2.val:\n            return False\n        \n        if node1.left and node2.left:\n            queue.append((node1.left, node2.left))\n        elif node1.left or node2.left:\n            return False\n        \n        if node1.right and node2.right:\n            queue.append((node1.right, node2.right))\n        elif node1.right or node2.right:\n            return False\n    \n    return True\n"})}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-dfs",children:"When to Use DFS"}),"\n",(0,i.jsx)(n.h3,{id:"-use-dfs-when-you-need",children:"\u2705 Use DFS when you need:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Path Finding"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Finding any path (not necessarily shortest)"}),"\n",(0,i.jsx)(n.li,{children:"Exploring all possible paths"}),"\n",(0,i.jsx)(n.li,{children:"Backtracking problems"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Tree/Graph Traversal"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"In-order, pre-order, post-order tree traversal"}),"\n",(0,i.jsx)(n.li,{children:"Exploring connected components"}),"\n",(0,i.jsx)(n.li,{children:"Topological sorting"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Memory Efficiency"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"When you need to minimize memory usage"}),"\n",(0,i.jsx)(n.li,{children:"Deep trees where BFS would use too much memory"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"dfs-examples",children:"DFS Examples:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Path Sum:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def has_path_sum(root, target_sum):\n    if not root:\n        return False\n    \n    if not root.left and not root.right:\n        return root.val == target_sum\n    \n    return (has_path_sum(root.left, target_sum - root.val) or\n            has_path_sum(root.right, target_sum - root.val))\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Connected Components:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def num_islands(grid):\n    if not grid:\n        return 0\n    \n    def dfs(i, j):\n        if (i < 0 or i >= len(grid) or \n            j < 0 or j >= len(grid[0]) or \n            grid[i][j] != '1'):\n            return\n        \n        grid[i][j] = '0'  # Mark as visited\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n    \n    islands = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                dfs(i, j)\n                islands += 1\n    \n    return islands\n"})}),"\n",(0,i.jsx)(n.h2,{id:"decision-framework",children:"Decision Framework"}),"\n",(0,i.jsx)(n.h3,{id:"ask-yourself-these-questions",children:"Ask yourself these questions:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Do I need the shortest path?"})," \u2192 BFS"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Do I need to process nodes level by level?"})," \u2192 BFS"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Am I comparing tree structures?"})," \u2192 BFS"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Do I need to explore all possible paths?"})," \u2192 DFS"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Is memory usage a concern?"})," \u2192 DFS"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Do I need to backtrack?"})," \u2192 DFS"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"real-world-problem-word-ladder",children:"Real-World Problem: Word Ladder"}),"\n",(0,i.jsx)(n.p,{children:"Let's solve the classic Word Ladder problem to see BFS in action:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": Transform one word into another by changing one letter at a time, where each intermediate word must be in a given dictionary."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def word_ladder(begin_word, end_word, word_list):\n    if end_word not in word_list:\n        return 0\n    \n    word_set = set(word_list)\n    queue = [(begin_word, 1)]\n    visited = {begin_word}\n    \n    while queue:\n        word, length = queue.pop(0)\n        \n        if word == end_word:\n            return length\n        \n        # Try changing each character\n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if c == word[i]:\n                    continue\n                \n                new_word = word[:i] + c + word[i+1:]\n                \n                if new_word in word_set and new_word not in visited:\n                    visited.add(new_word)\n                    queue.append((new_word, length + 1))\n    \n    return 0\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Why BFS?"})," Because we need the shortest transformation sequence, and BFS guarantees we'll find the minimum number of steps."]}),"\n",(0,i.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"time-complexity",children:"Time Complexity:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"BFS"}),": O(V + E) where V is vertices, E is edges"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"DFS"}),": O(V + E) where V is vertices, E is edges"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"space-complexity",children:"Space Complexity:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"BFS"}),": O(V) for the queue (worst case: all nodes at one level)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"DFS"}),": O(V) for the recursion stack (worst case: depth of tree)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-mistakes-to-avoid",children:"Common Mistakes to Avoid"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Using DFS for shortest path problems"})," - BFS is more efficient"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Using BFS for backtracking problems"})," - DFS with recursion is cleaner"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Not considering memory constraints"})," - DFS uses less memory for deep trees"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Forgetting to mark visited nodes"})," - Can lead to infinite loops"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"practice-problems",children:"Practice Problems"}),"\n",(0,i.jsx)(n.h3,{id:"bfs-problems",children:"BFS Problems:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-level-order-traversal/",children:"Binary Tree Level Order Traversal"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/same-tree/",children:"Same Tree"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/symmetric-tree/",children:"Symmetric Tree"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/word-ladder/",children:"Word Ladder"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"dfs-problems",children:"DFS Problems:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/maximum-depth-of-binary-tree/",children:"Maximum Depth of Binary Tree"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/path-sum/",children:"Path Sum"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/number-of-islands/",children:"Number of Islands"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/validate-binary-search-tree/",children:"Validate Binary Search Tree"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"The choice between DFS and BFS often comes down to the nature of your problem:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"BFS"})," is your go-to for shortest path, level-based operations, and tree comparisons"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"DFS"})," excels at path exploration, backtracking, and memory-efficient traversal"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Remember: both algorithms have the same time complexity, but their space usage patterns and problem-solving approaches differ significantly. Choose the one that best fits your problem's requirements and constraints."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"What's your experience with DFS vs BFS? Do you have any tips for recognizing which algorithm to use in interviews?"})})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);