"use strict";(globalThis.webpackChunkbytesofpurpose_blog=globalThis.webpackChunkbytesofpurpose_blog||[]).push([[38861],{28453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>d});var s=r(96540);const i={},l=s.createContext(i);function t(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(l.Provider,{value:n},e.children)}},40851:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>a,frontMatter:()=>t,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"mental-models/understanding-data-structs-and-algos/understanding-graphs","title":"Understanding Graphs: A Complete Mental Model for Network Analysis, Algorithms, and Problem-Solving","description":"A comprehensive guide covering graph types, modeling approaches, essential algorithms (topological sort, MST, shortest paths), and practical problem-solving strategies with real LeetCode examples.","source":"@site/docs/3-mental-models/1-understanding-data-structs-and-algos/understanding-graphs.mdx","sourceDirName":"3-mental-models/1-understanding-data-structs-and-algos","slug":"/mental-models/understanding-data-structs-and-algos/understanding-graphs","permalink":"/docs/mental-models/understanding-data-structs-and-algos/understanding-graphs","draft":false,"unlisted":false,"editUrl":"https://github.com/omars-lab/omars-lab.github.io/edit/master/bytesofpurpose-blog/docs/3-mental-models/1-understanding-data-structs-and-algos/understanding-graphs.mdx","tags":[{"inline":true,"label":"data-structures","permalink":"/docs/tags/data-structures"},{"inline":true,"label":"algorithms","permalink":"/docs/tags/algorithms"},{"inline":true,"label":"graphs","permalink":"/docs/tags/graphs"},{"inline":true,"label":"networks","permalink":"/docs/tags/networks"},{"inline":true,"label":"pathfinding","permalink":"/docs/tags/pathfinding"},{"inline":true,"label":"computer-science","permalink":"/docs/tags/computer-science"},{"inline":true,"label":"topological-sort","permalink":"/docs/tags/topological-sort"},{"inline":true,"label":"mst","permalink":"/docs/tags/mst"},{"inline":true,"label":"shortest-path","permalink":"/docs/tags/shortest-path"}],"version":"current","frontMatter":{"slug":"understanding-graphs","title":"Understanding Graphs: A Complete Mental Model for Network Analysis, Algorithms, and Problem-Solving","description":"A comprehensive guide covering graph types, modeling approaches, essential algorithms (topological sort, MST, shortest paths), and practical problem-solving strategies with real LeetCode examples.","authors":["oeid"],"tags":["data-structures","algorithms","graphs","networks","pathfinding","computer-science","topological-sort","mst","shortest-path"],"date":"2025-01-31T10:00","draft":false},"sidebar":"changelogSidebar","previous":{"title":"Understanding Dynamic Programming: A Complete Mental Model for Algorithm Optimization and Problem-Solving","permalink":"/docs/mental-models/understanding-data-structs-and-algos/understanding-dynamic-programming"},"next":{"title":"Understanding Heaps: A Complete Mental Model for Data Structure Mastery and Problem-Solving","permalink":"/docs/mental-models/understanding-data-structs-and-algos/understanding-heaps"}}');var i=r(74848),l=r(28453);const t={slug:"understanding-graphs",title:"Understanding Graphs: A Complete Mental Model for Network Analysis, Algorithms, and Problem-Solving",description:"A comprehensive guide covering graph types, modeling approaches, essential algorithms (topological sort, MST, shortest paths), and practical problem-solving strategies with real LeetCode examples.",authors:["oeid"],tags:["data-structures","algorithms","graphs","networks","pathfinding","computer-science","topological-sort","mst","shortest-path"],date:"2025-01-31T10:00",draft:!1},d="Understanding Graphs: A Complete Mental Model for Network Analysis, Algorithms, and Problem-Solving",c={},o=[{value:"Purpose",id:"purpose",level:2},{value:"What are Graphs?",id:"what-are-graphs",level:2},{value:"Key Components",id:"key-components",level:3},{value:"Types of Graphs: A Comprehensive Classification",id:"types-of-graphs-a-comprehensive-classification",level:2},{value:"1. Directed vs Undirected Graphs",id:"1-directed-vs-undirected-graphs",level:3},{value:"Directed Graph (Digraph)",id:"directed-graph-digraph",level:4},{value:"Undirected Graph",id:"undirected-graph",level:4},{value:"2. Weighted vs Unweighted Graphs",id:"2-weighted-vs-unweighted-graphs",level:3},{value:"Weighted Graph",id:"weighted-graph",level:4},{value:"Unweighted Graph",id:"unweighted-graph",level:4},{value:"3. Connected vs Disconnected Graphs",id:"3-connected-vs-disconnected-graphs",level:3},{value:"Connected Graph",id:"connected-graph",level:4},{value:"Disconnected Graph",id:"disconnected-graph",level:4},{value:"4. Acyclic vs Cyclic Graphs",id:"4-acyclic-vs-cyclic-graphs",level:3},{value:"Acyclic Graph (DAG - Directed Acyclic Graph)",id:"acyclic-graph-dag---directed-acyclic-graph",level:4},{value:"Cyclic Graph",id:"cyclic-graph",level:4},{value:"5. Special Graph Types",id:"5-special-graph-types",level:3},{value:"Complete Graph",id:"complete-graph",level:4},{value:"Bipartite Graph",id:"bipartite-graph",level:4},{value:"Tree",id:"tree",level:4},{value:"Forest",id:"forest",level:4},{value:"6. Graph Density Classifications",id:"6-graph-density-classifications",level:3},{value:"Dense Graph",id:"dense-graph",level:4},{value:"Sparse Graph",id:"sparse-graph",level:4},{value:"7. Graph Connectivity Levels",id:"7-graph-connectivity-levels",level:3},{value:"Strongly Connected (Directed)",id:"strongly-connected-directed",level:4},{value:"Weakly Connected (Directed)",id:"weakly-connected-directed",level:4},{value:"k-Connected",id:"k-connected",level:4},{value:"Graph Type Selection Guide",id:"graph-type-selection-guide",level:2},{value:"Graph Properties Summary",id:"graph-properties-summary",level:2},{value:"Key Distinctions: Graphs vs Other Data Structures",id:"key-distinctions-graphs-vs-other-data-structures",level:2},{value:"Graphs vs Trees",id:"graphs-vs-trees",level:3},{value:"Key Differences",id:"key-differences",level:4},{value:"Visual Comparison",id:"visual-comparison",level:4},{value:"When to Use Each",id:"when-to-use-each",level:4},{value:"Graphs vs Arrays/Lists",id:"graphs-vs-arrayslists",level:3},{value:"Key Differences",id:"key-differences-1",level:4},{value:"When to Use Each",id:"when-to-use-each-1",level:4},{value:"Graphs vs Hash Maps",id:"graphs-vs-hash-maps",level:3},{value:"Key Differences",id:"key-differences-2",level:4},{value:"When to Use Each",id:"when-to-use-each-2",level:4},{value:"Graph Modeling Approaches",id:"graph-modeling-approaches",level:2},{value:"1. Adjacency Matrix",id:"1-adjacency-matrix",level:3},{value:"2. Adjacency List",id:"2-adjacency-list",level:3},{value:"3. Edge List",id:"3-edge-list",level:3},{value:"4. Object-Oriented Node Representation",id:"4-object-oriented-node-representation",level:3},{value:"5. Hash Map Representation",id:"5-hash-map-representation",level:3},{value:"Problem-Specific Modeling Guidelines",id:"problem-specific-modeling-guidelines",level:2},{value:"If solving problems like this, model this way:",id:"if-solving-problems-like-this-model-this-way",level:3},{value:"Graph Representation Comparison",id:"graph-representation-comparison",level:2},{value:"Quick Decision Guide",id:"quick-decision-guide",level:2},{value:"Essential Graph Algorithms",id:"essential-graph-algorithms",level:2},{value:"Cycle Detection Algorithms",id:"cycle-detection-algorithms",level:2},{value:"1. DFS-based Cycle Detection",id:"1-dfs-based-cycle-detection",level:3},{value:"Directed Graph Cycle Detection",id:"directed-graph-cycle-detection",level:4},{value:"Undirected Graph Cycle Detection",id:"undirected-graph-cycle-detection",level:4},{value:"2. Tarjan&#39;s Strongly Connected Components (SCC)",id:"2-tarjans-strongly-connected-components-scc",level:3},{value:"3. Union-Find Cycle Detection",id:"3-union-find-cycle-detection",level:3},{value:"4. Kahn&#39;s Algorithm (Topological Sort)",id:"4-kahns-algorithm-topological-sort",level:3},{value:"Cycle Detection Problem Patterns",id:"cycle-detection-problem-patterns",level:2},{value:"Pattern 1: Dependency Cycle Detection",id:"pattern-1-dependency-cycle-detection",level:3},{value:"Pattern 2: Undirected Graph Cycle Detection",id:"pattern-2-undirected-graph-cycle-detection",level:3},{value:"Pattern 3: Strongly Connected Components",id:"pattern-3-strongly-connected-components",level:3},{value:"Cycle Detection Algorithm Comparison",id:"cycle-detection-algorithm-comparison",level:2},{value:"When to Use Each Cycle Detection Method",id:"when-to-use-each-cycle-detection-method",level:2},{value:"Use DFS Color Coding when:",id:"use-dfs-color-coding-when",level:3},{value:"Use Tarjan&#39;s Algorithm when:",id:"use-tarjans-algorithm-when",level:3},{value:"Use Union-Find when:",id:"use-union-find-when",level:3},{value:"Use Kahn&#39;s Algorithm when:",id:"use-kahns-algorithm-when",level:3},{value:"1. Topological Sort",id:"1-topological-sort",level:3},{value:"DFS-based Topological Sort (Kahn&#39;s Algorithm)",id:"dfs-based-topological-sort-kahns-algorithm",level:4},{value:"BFS-based Topological Sort (Kahn&#39;s Algorithm)",id:"bfs-based-topological-sort-kahns-algorithm",level:4},{value:"2. Strongly Connected Components (SCC)",id:"2-strongly-connected-components-scc",level:3},{value:"Tarjan&#39;s Algorithm",id:"tarjans-algorithm",level:4},{value:"3. Minimum Spanning Tree (MST)",id:"3-minimum-spanning-tree-mst",level:3},{value:"Kruskal&#39;s Algorithm",id:"kruskals-algorithm",level:4},{value:"Prim&#39;s Algorithm",id:"prims-algorithm",level:4},{value:"4. Shortest Path Algorithms",id:"4-shortest-path-algorithms",level:3},{value:"Dijkstra&#39;s Algorithm (Single Source)",id:"dijkstras-algorithm-single-source",level:4},{value:"Bellman-Ford Algorithm",id:"bellman-ford-algorithm",level:4},{value:"Floyd-Warshall Algorithm",id:"floyd-warshall-algorithm",level:4},{value:"5. Graph Coloring",id:"5-graph-coloring",level:3},{value:"Algorithm Selection Guide",id:"algorithm-selection-guide",level:2},{value:"Graph Traversal Algorithms",id:"graph-traversal-algorithms",level:2},{value:"1. Depth-First Search (DFS)",id:"1-depth-first-search-dfs",level:3},{value:"2. Breadth-First Search (BFS)",id:"2-breadth-first-search-bfs",level:3},{value:"Shortest Path Algorithms",id:"shortest-path-algorithms",level:2},{value:"1. Dijkstra&#39;s Algorithm",id:"1-dijkstras-algorithm",level:3},{value:"2. Bellman-Ford Algorithm",id:"2-bellman-ford-algorithm",level:3},{value:"3. Floyd-Warshall Algorithm",id:"3-floyd-warshall-algorithm",level:3},{value:"Advanced Graph Algorithms",id:"advanced-graph-algorithms",level:2},{value:"1. Topological Sort",id:"1-topological-sort-1",level:3},{value:"2. Strongly Connected Components (Tarjan&#39;s)",id:"2-strongly-connected-components-tarjans",level:3},{value:"3. Minimum Spanning Tree (Kruskal&#39;s)",id:"3-minimum-spanning-tree-kruskals",level:3},{value:"Graph Problem Patterns",id:"graph-problem-patterns",level:2},{value:"1. Cycle Detection",id:"1-cycle-detection",level:3},{value:"2. Bipartite Graph Detection",id:"2-bipartite-graph-detection",level:3},{value:"Common Graph Mistakes to Avoid",id:"common-graph-mistakes-to-avoid",level:2},{value:"Graph Algorithm Complexity",id:"graph-algorithm-complexity",level:2},{value:"Action Items",id:"action-items",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components},{Details:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"understanding-graphs-a-complete-mental-model-for-network-analysis-algorithms-and-problem-solving",children:"Understanding Graphs: A Complete Mental Model for Network Analysis, Algorithms, and Problem-Solving"})}),"\n",(0,i.jsx)(n.p,{children:"A comprehensive guide covering graph types, modeling approaches, essential algorithms (topological sort, MST, shortest paths), and practical problem-solving strategies with real LeetCode examples."}),"\n",(0,i.jsx)(n.h2,{id:"purpose",children:"Purpose"}),"\n",(0,i.jsx)(n.p,{children:"This guide was created to address four critical needs:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"I need to understand graph fundamentals"}),": Learn the core concepts, representations, and properties of graph data structures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"I need to master graph traversal"}),": Implement and understand BFS, DFS, and their variations for different problem types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"I need to solve pathfinding problems"}),": Apply shortest path algorithms like Dijkstra's and A* for optimization problems"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"I need to analyze network structures"}),": Use graph algorithms to understand connectivity, cycles, and topological relationships"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The goal is to transform confusion about graph algorithms into clear, systematic problem-solving skills through structured learning and pattern recognition."}),"\n",(0,i.jsx)(n.h2,{id:"what-are-graphs",children:"What are Graphs?"}),"\n",(0,i.jsx)(n.p,{children:"A graph is a collection of vertices (nodes) connected by edges (links) that represents relationships between entities."}),"\n",(0,i.jsx)(n.h3,{id:"key-components",children:"Key Components"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Vertices (Nodes)"}),": The fundamental units of a graph"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Edges (Links)"}),": Connections between vertices"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Directed/Undirected"}),": Edges may have direction or be bidirectional"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Weighted/Unweighted"}),": Edges may have associated costs or weights"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"types-of-graphs-a-comprehensive-classification",children:"Types of Graphs: A Comprehensive Classification"}),"\n",(0,i.jsx)(n.p,{children:"Understanding the different types of graphs is crucial for choosing the right algorithms and data structures. Each graph type has unique properties that affect how we can traverse, analyze, and solve problems on them."}),"\n",(0,i.jsx)(n.h3,{id:"1-directed-vs-undirected-graphs",children:"1. Directed vs Undirected Graphs"}),"\n",(0,i.jsx)(n.h4,{id:"directed-graph-digraph",children:"Directed Graph (Digraph)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"A \u2192 B \u2192 C\n\u2193   \u2191   \u2193\nD \u2192 E \u2192 F\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Properties"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Edges have direction (A\u2192B \u2260 B\u2192A)"}),"\n",(0,i.jsx)(n.li,{children:"Asymmetric relationships"}),"\n",(0,i.jsx)(n.li,{children:"Can have cycles"}),"\n",(0,i.jsx)(n.li,{children:"In-degree and out-degree concepts"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Dependency relationships (prerequisites)"}),"\n",(0,i.jsx)(n.li,{children:"Web page links"}),"\n",(0,i.jsx)(n.li,{children:"Social media follows"}),"\n",(0,i.jsx)(n.li,{children:"State transitions"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule/",children:"Course Schedule"})," - Prerequisites"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/alien-dictionary/",children:"Alien Dictionary"})," - Character ordering"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"undirected-graph",children:"Undirected Graph"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"A \u2014 B \u2014 C\n|   |   |\nD \u2014 E \u2014 F\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Properties"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Bidirectional edges (A\u2014B = B\u2014A)"}),"\n",(0,i.jsx)(n.li,{children:"Symmetric relationships"}),"\n",(0,i.jsx)(n.li,{children:"Simpler connectivity analysis"}),"\n",(0,i.jsx)(n.li,{children:"Degree = number of incident edges"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Social networks (friendships)"}),"\n",(0,i.jsx)(n.li,{children:"Road networks"}),"\n",(0,i.jsx)(n.li,{children:"Communication networks"}),"\n",(0,i.jsx)(n.li,{children:"Collaborative relationships"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/number-of-islands/",children:"Number of Islands"})," - Connected components"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/friend-circles/",children:"Friend Circles"})," - Social connections"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-weighted-vs-unweighted-graphs",children:"2. Weighted vs Unweighted Graphs"}),"\n",(0,i.jsx)(n.h4,{id:"weighted-graph",children:"Weighted Graph"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"A --5-- B --3-- C\n|       |       |\n2       1       4\n|       |       |\nD --2-- E --6-- F\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Properties"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Edges have associated costs/weights"}),"\n",(0,i.jsx)(n.li,{children:"Optimization problems"}),"\n",(0,i.jsx)(n.li,{children:"Shortest path algorithms"}),"\n",(0,i.jsx)(n.li,{children:"Minimum spanning trees"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Network routing (distances, costs)"}),"\n",(0,i.jsx)(n.li,{children:"Resource allocation"}),"\n",(0,i.jsx)(n.li,{children:"Optimization problems"}),"\n",(0,i.jsx)(n.li,{children:"Game theory"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/network-delay-time/",children:"Network Delay Time"})," - Weighted shortest path"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/min-cost-to-connect-all-points/",children:"Min Cost to Connect All Points"})," - MST"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"unweighted-graph",children:"Unweighted Graph"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"A \u2014 B \u2014 C\n|   |   |\nD \u2014 E \u2014 F\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Properties"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"All edges have equal weight (typically 1)"}),"\n",(0,i.jsx)(n.li,{children:"Focus on connectivity"}),"\n",(0,i.jsx)(n.li,{children:"Simpler algorithms"}),"\n",(0,i.jsx)(n.li,{children:"BFS gives shortest path"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Social networks"}),"\n",(0,i.jsx)(n.li,{children:"Web crawling"}),"\n",(0,i.jsx)(n.li,{children:"Game states"}),"\n",(0,i.jsx)(n.li,{children:"Simple connectivity problems"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/word-ladder/",children:"Word Ladder"})," - Unweighted shortest path"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-level-order-traversal/",children:"Binary Tree Level Order"})," - Level traversal"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-connected-vs-disconnected-graphs",children:"3. Connected vs Disconnected Graphs"}),"\n",(0,i.jsx)(n.h4,{id:"connected-graph",children:"Connected Graph"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"A \u2014 B \u2014 C\n|   |   |\nD \u2014 E \u2014 F\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Every vertex is reachable from every other vertex"}),"\n",(0,i.jsx)(n.li,{children:"Single connected component"}),"\n",(0,i.jsx)(n.li,{children:"No isolated vertices"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"disconnected-graph",children:"Disconnected Graph"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"A \u2014 B    C \u2014 D\n|   |    |   |\nE \u2014 F    G \u2014 H\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Multiple connected components"}),"\n",(0,i.jsx)(n.li,{children:"Some vertices unreachable from others"}),"\n",(0,i.jsx)(n.li,{children:"Requires multiple traversals"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/number-of-islands/",children:"Number of Islands"})," - Multiple components"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/friend-circles/",children:"Friend Circles"})," - Disconnected social groups"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"4-acyclic-vs-cyclic-graphs",children:"4. Acyclic vs Cyclic Graphs"}),"\n",(0,i.jsx)(n.h4,{id:"acyclic-graph-dag---directed-acyclic-graph",children:"Acyclic Graph (DAG - Directed Acyclic Graph)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"A \u2192 B \u2192 C\n\u2193   \u2191\nD \u2192 E\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No cycles"}),"\n",(0,i.jsx)(n.li,{children:"Topological ordering possible"}),"\n",(0,i.jsx)(n.li,{children:"Tree-like structure"}),"\n",(0,i.jsx)(n.li,{children:"Dependency resolution"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Task scheduling"}),"\n",(0,i.jsx)(n.li,{children:"Build systems"}),"\n",(0,i.jsx)(n.li,{children:"Course prerequisites"}),"\n",(0,i.jsx)(n.li,{children:"Compiler dependency analysis"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule/",children:"Course Schedule"})," - DAG validation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/task-scheduler/",children:"Task Scheduler"})," - Dependency ordering"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"cyclic-graph",children:"Cyclic Graph"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"A \u2192 B \u2192 C\n\u2191   \u2193   \u2193\nD \u2190 E \u2190 F\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Contains cycles"}),"\n",(0,i.jsx)(n.li,{children:"Can revisit vertices"}),"\n",(0,i.jsx)(n.li,{children:"More complex algorithms"}),"\n",(0,i.jsx)(n.li,{children:"Infinite traversal possible"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Game states"}),"\n",(0,i.jsx)(n.li,{children:"State machines"}),"\n",(0,i.jsx)(n.li,{children:"Network analysis"}),"\n",(0,i.jsx)(n.li,{children:"Social networks"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/clone-graph/",children:"Clone Graph"})," - Cyclic graph cloning"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule/",children:"Course Schedule"})," - Cycle detection"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"5-special-graph-types",children:"5. Special Graph Types"}),"\n",(0,i.jsx)(n.h4,{id:"complete-graph",children:"Complete Graph"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"A \u2014 B\n| \\ |\nC \u2014 D\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Every vertex connected to every other vertex"}),"\n",(0,i.jsx)(n.li,{children:"Maximum number of edges: n(n-1)/2 for undirected"}),"\n",(0,i.jsx)(n.li,{children:"Dense graph"}),"\n",(0,i.jsx)(n.li,{children:"High connectivity"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Network analysis"}),"\n",(0,i.jsx)(n.li,{children:"Clustering problems"}),"\n",(0,i.jsx)(n.li,{children:"Social network analysis"}),"\n",(0,i.jsx)(n.li,{children:"Game theory"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"bipartite-graph",children:"Bipartite Graph"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"A \u2014 B \u2014 C\n|   |   |\nD \u2014 E \u2014 F\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Vertices can be divided into two sets"}),"\n",(0,i.jsx)(n.li,{children:"No edges within the same set"}),"\n",(0,i.jsx)(n.li,{children:"2-colorable"}),"\n",(0,i.jsx)(n.li,{children:"Matching problems"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Assignment problems"}),"\n",(0,i.jsx)(n.li,{children:"Matching algorithms"}),"\n",(0,i.jsx)(n.li,{children:"Scheduling conflicts"}),"\n",(0,i.jsx)(n.li,{children:"Resource allocation"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/is-graph-bipartite/",children:"Is Graph Bipartite?"})," - Bipartite detection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule/",children:"Course Schedule"})," - Conflict detection"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"tree",children:"Tree"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"    A\n   / \\\n  B   C\n / \\   \\\nD   E   F\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Connected acyclic graph"}),"\n",(0,i.jsx)(n.li,{children:"n-1 edges for n vertices"}),"\n",(0,i.jsx)(n.li,{children:"Unique path between any two vertices"}),"\n",(0,i.jsx)(n.li,{children:"Hierarchical structure"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Hierarchical data"}),"\n",(0,i.jsx)(n.li,{children:"File systems"}),"\n",(0,i.jsx)(n.li,{children:"Decision trees"}),"\n",(0,i.jsx)(n.li,{children:"Family trees"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-level-order-traversal/",children:"Binary Tree Level Order"})," - Tree traversal"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/validate-binary-search-tree/",children:"Validate BST"})," - Tree validation"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"forest",children:"Forest"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"A \u2014 B    C \u2014 D\n|   |    |   |\nE \u2014 F    G \u2014 H\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Collection of trees"}),"\n",(0,i.jsx)(n.li,{children:"Multiple connected components"}),"\n",(0,i.jsx)(n.li,{children:"No cycles"}),"\n",(0,i.jsx)(n.li,{children:"Disconnected acyclic graph"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"6-graph-density-classifications",children:"6. Graph Density Classifications"}),"\n",(0,i.jsx)(n.h4,{id:"dense-graph",children:"Dense Graph"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Many edges relative to vertices"}),"\n",(0,i.jsx)(n.li,{children:"E \u2248 V\xb2"}),"\n",(0,i.jsx)(n.li,{children:"Adjacency matrix efficient"}),"\n",(0,i.jsx)(n.li,{children:"High connectivity"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"sparse-graph",children:"Sparse Graph"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Few edges relative to vertices"}),"\n",(0,i.jsxs)(n.li,{children:["E ","<<"," V\xb2"]}),"\n",(0,i.jsx)(n.li,{children:"Adjacency list efficient"}),"\n",(0,i.jsx)(n.li,{children:"Low connectivity"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"7-graph-connectivity-levels",children:"7. Graph Connectivity Levels"}),"\n",(0,i.jsx)(n.h4,{id:"strongly-connected-directed",children:"Strongly Connected (Directed)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Every vertex reachable from every other vertex"}),"\n",(0,i.jsx)(n.li,{children:"Mutual reachability"}),"\n",(0,i.jsx)(n.li,{children:"Tarjan's algorithm"}),"\n",(0,i.jsx)(n.li,{children:"Network reliability"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"weakly-connected-directed",children:"Weakly Connected (Directed)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Connected when directions ignored"}),"\n",(0,i.jsx)(n.li,{children:"Easier to analyze"}),"\n",(0,i.jsx)(n.li,{children:"Union-Find applicable"}),"\n",(0,i.jsx)(n.li,{children:"Social network analysis"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"k-connected",children:"k-Connected"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Requires k vertices to disconnect"}),"\n",(0,i.jsx)(n.li,{children:"Network robustness"}),"\n",(0,i.jsx)(n.li,{children:"Critical infrastructure"}),"\n",(0,i.jsx)(n.li,{children:"Fault tolerance"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"graph-type-selection-guide",children:"Graph Type Selection Guide"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Problem Type"}),(0,i.jsx)(n.th,{children:"Best Graph Type"}),(0,i.jsx)(n.th,{children:"Key Properties"}),(0,i.jsx)(n.th,{children:"Algorithms"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Dependencies"}),(0,i.jsx)(n.td,{children:"Directed Acyclic"}),(0,i.jsx)(n.td,{children:"No cycles, ordering"}),(0,i.jsx)(n.td,{children:"Topological Sort"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Social Networks"}),(0,i.jsx)(n.td,{children:"Undirected, Weighted"}),(0,i.jsx)(n.td,{children:"Symmetric, influence"}),(0,i.jsx)(n.td,{children:"Community Detection"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Navigation"}),(0,i.jsx)(n.td,{children:"Directed, Weighted"}),(0,i.jsx)(n.td,{children:"Asymmetric, costs"}),(0,i.jsx)(n.td,{children:"Dijkstra's, A*"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Scheduling"}),(0,i.jsx)(n.td,{children:"Bipartite"}),(0,i.jsx)(n.td,{children:"Two sets, matching"}),(0,i.jsx)(n.td,{children:"Hungarian Algorithm"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Hierarchies"}),(0,i.jsx)(n.td,{children:"Tree"}),(0,i.jsx)(n.td,{children:"Acyclic, parent-child"}),(0,i.jsx)(n.td,{children:"DFS, BFS"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Optimization"}),(0,i.jsx)(n.td,{children:"Complete, Weighted"}),(0,i.jsx)(n.td,{children:"All connections, costs"}),(0,i.jsx)(n.td,{children:"TSP, MST"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Connectivity"}),(0,i.jsx)(n.td,{children:"Undirected"}),(0,i.jsx)(n.td,{children:"Symmetric, reachability"}),(0,i.jsx)(n.td,{children:"Union-Find, DFS"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"graph-properties-summary",children:"Graph Properties Summary"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Property"}),(0,i.jsx)(n.th,{children:"Directed"}),(0,i.jsx)(n.th,{children:"Undirected"}),(0,i.jsx)(n.th,{children:"Weighted"}),(0,i.jsx)(n.th,{children:"Tree"}),(0,i.jsx)(n.th,{children:"Bipartite"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Direction"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u274c"}),(0,i.jsx)(n.td,{children:"Either"}),(0,i.jsx)(n.td,{children:"Either"}),(0,i.jsx)(n.td,{children:"Either"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Cycles"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"Either"}),(0,i.jsx)(n.td,{children:"\u274c"}),(0,i.jsx)(n.td,{children:"\u2705"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Connectivity"}),(0,i.jsx)(n.td,{children:"Variable"}),(0,i.jsx)(n.td,{children:"Variable"}),(0,i.jsx)(n.td,{children:"Variable"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"Variable"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Coloring"}),(0,i.jsx)(n.td,{children:"Complex"}),(0,i.jsx)(n.td,{children:"2-colorable"}),(0,i.jsx)(n.td,{children:"Complex"}),(0,i.jsx)(n.td,{children:"2-colorable"}),(0,i.jsx)(n.td,{children:"2-colorable"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Shortest Path"}),(0,i.jsx)(n.td,{children:"Dijkstra's"}),(0,i.jsx)(n.td,{children:"BFS/Dijkstra's"}),(0,i.jsx)(n.td,{children:"Dijkstra's"}),(0,i.jsx)(n.td,{children:"BFS"}),(0,i.jsx)(n.td,{children:"BFS"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"MST"}),(0,i.jsx)(n.td,{children:"N/A"}),(0,i.jsx)(n.td,{children:"Kruskal's/Prim's"}),(0,i.jsx)(n.td,{children:"Kruskal's/Prim's"}),(0,i.jsx)(n.td,{children:"N/A"}),(0,i.jsx)(n.td,{children:"Kruskal's/Prim's"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"key-distinctions-graphs-vs-other-data-structures",children:"Key Distinctions: Graphs vs Other Data Structures"}),"\n",(0,i.jsx)(n.p,{children:"Understanding the fundamental differences between graphs and other data structures is crucial for choosing the right approach to solve problems."}),"\n",(0,i.jsx)(n.h3,{id:"graphs-vs-trees",children:"Graphs vs Trees"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u274c Common Misconception"}),': "Graphs and trees are the same thing"']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u2705 Reality"}),": Trees are a special type of graph, but graphs are much more general"]}),"\n",(0,i.jsx)(n.h4,{id:"key-differences",children:"Key Differences"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"Graphs"}),(0,i.jsx)(n.th,{children:"Trees"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Cycles"})}),(0,i.jsx)(n.td,{children:"\u2705 Can have cycles"}),(0,i.jsx)(n.td,{children:"\u274c No cycles (acyclic)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Connectivity"})}),(0,i.jsx)(n.td,{children:"Can be disconnected"}),(0,i.jsx)(n.td,{children:"Always connected"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Root"})}),(0,i.jsx)(n.td,{children:"No concept of root"}),(0,i.jsx)(n.td,{children:"Has a single root node"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Parent-Child"})}),(0,i.jsx)(n.td,{children:"No hierarchical structure"}),(0,i.jsx)(n.td,{children:"Clear parent-child relationships"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Paths"})}),(0,i.jsx)(n.td,{children:"Multiple paths between nodes"}),(0,i.jsx)(n.td,{children:"Unique path between any two nodes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Edges"})}),(0,i.jsx)(n.td,{children:"Can be directed/undirected"}),(0,i.jsx)(n.td,{children:"Usually directed (parent \u2192 child)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Complexity"})}),(0,i.jsx)(n.td,{children:"More complex algorithms"}),(0,i.jsx)(n.td,{children:"Simpler traversal (DFS/BFS)"})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"visual-comparison",children:"Visual Comparison"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Graph (with cycles)"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"A \u2014 B \u2014 C\n|   |   |\nD \u2014 E \u2014 F\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Multiple paths: A\u2192B\u2192C and A\u2192D\u2192E\u2192F\u2192C"}),"\n",(0,i.jsx)(n.li,{children:"Can have cycles: A\u2192B\u2192E\u2192D\u2192A"}),"\n",(0,i.jsx)(n.li,{children:"No root concept"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Tree (no cycles)"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"    A\n   / \\\n  B   C\n / \\   \\\nD   E   F\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Unique path: A\u2192B\u2192D (only one way)"}),"\n",(0,i.jsx)(n.li,{children:"No cycles possible"}),"\n",(0,i.jsx)(n.li,{children:"Clear root (A) and hierarchy"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"when-to-use-each",children:"When to Use Each"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Graphs when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Multiple paths between nodes"}),"\n",(0,i.jsx)(n.li,{children:"Cycles are possible/desired"}),"\n",(0,i.jsx)(n.li,{children:"Complex relationships (social networks, web pages)"}),"\n",(0,i.jsx)(n.li,{children:"Need to find shortest paths"}),"\n",(0,i.jsx)(n.li,{children:"Network analysis required"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Trees when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Hierarchical data (file systems, organization charts)"}),"\n",(0,i.jsx)(n.li,{children:"Unique parent-child relationships"}),"\n",(0,i.jsx)(n.li,{children:"No cycles allowed"}),"\n",(0,i.jsx)(n.li,{children:"Simple traversal needed"}),"\n",(0,i.jsx)(n.li,{children:"Decision making (decision trees)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Graph Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule/",children:"Course Schedule"})," - Cycle detection in dependencies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tree Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-level-order-traversal/",children:"Binary Tree Level Order"})," - Hierarchical traversal"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"graphs-vs-arrayslists",children:"Graphs vs Arrays/Lists"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u274c Common Misconception"}),': "Graphs are just arrays with connections"']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u2705 Reality"}),": Graphs represent relationships, arrays represent sequences"]}),"\n",(0,i.jsx)(n.h4,{id:"key-differences-1",children:"Key Differences"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"Graphs"}),(0,i.jsx)(n.th,{children:"Arrays/Lists"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Structure"})}),(0,i.jsx)(n.td,{children:"Nodes + Edges (relationships)"}),(0,i.jsx)(n.td,{children:"Sequential elements"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Access"})}),(0,i.jsx)(n.td,{children:"Traversal-based"}),(0,i.jsx)(n.td,{children:"Index-based O(1)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Relationships"})}),(0,i.jsx)(n.td,{children:"Complex, multi-directional"}),(0,i.jsx)(n.td,{children:"Linear, sequential"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Algorithms"})}),(0,i.jsx)(n.td,{children:"DFS, BFS, shortest path"}),(0,i.jsx)(n.td,{children:"Binary search, sorting"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Memory"})}),(0,i.jsx)(n.td,{children:"Adjacency list/matrix"}),(0,i.jsx)(n.td,{children:"Contiguous memory"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Use Cases"})}),(0,i.jsx)(n.td,{children:"Networks, relationships"}),(0,i.jsx)(n.td,{children:"Data storage, sequences"})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"when-to-use-each-1",children:"When to Use Each"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Graphs when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Modeling relationships (social networks, dependencies)"}),"\n",(0,i.jsx)(n.li,{children:"Finding connections between entities"}),"\n",(0,i.jsx)(n.li,{children:"Network analysis"}),"\n",(0,i.jsx)(n.li,{children:"Pathfinding problems"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Arrays when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Storing sequential data"}),"\n",(0,i.jsx)(n.li,{children:"Need random access"}),"\n",(0,i.jsx)(n.li,{children:"Simple data structures"}),"\n",(0,i.jsx)(n.li,{children:"Performance-critical applications"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"graphs-vs-hash-maps",children:"Graphs vs Hash Maps"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u274c Common Misconception"}),': "Graphs are just hash maps with connections"']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u2705 Reality"}),": Hash maps store key-value pairs, graphs store relationships"]}),"\n",(0,i.jsx)(n.h4,{id:"key-differences-2",children:"Key Differences"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"Graphs"}),(0,i.jsx)(n.th,{children:"Hash Maps"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Purpose"})}),(0,i.jsx)(n.td,{children:"Model relationships"}),(0,i.jsx)(n.td,{children:"Store key-value pairs"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Structure"})}),(0,i.jsx)(n.td,{children:"Nodes + Edges"}),(0,i.jsx)(n.td,{children:"Key \u2192 Value mapping"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Algorithms"})}),(0,i.jsx)(n.td,{children:"Traversal, pathfinding"}),(0,i.jsx)(n.td,{children:"Lookup, insertion"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Complexity"})}),(0,i.jsx)(n.td,{children:"O(V + E) operations"}),(0,i.jsx)(n.td,{children:"O(1) average lookup"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Use Cases"})}),(0,i.jsx)(n.td,{children:"Network analysis"}),(0,i.jsx)(n.td,{children:"Data storage, caching"})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"when-to-use-each-2",children:"When to Use Each"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Graphs when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Need to traverse relationships"}),"\n",(0,i.jsx)(n.li,{children:"Finding paths between nodes"}),"\n",(0,i.jsx)(n.li,{children:"Network analysis"}),"\n",(0,i.jsx)(n.li,{children:"Dependency resolution"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Hash Maps when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fast key-value lookups"}),"\n",(0,i.jsx)(n.li,{children:"Caching data"}),"\n",(0,i.jsx)(n.li,{children:"Counting frequencies"}),"\n",(0,i.jsx)(n.li,{children:"Simple data storage"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"graph-modeling-approaches",children:"Graph Modeling Approaches"}),"\n",(0,i.jsx)(n.p,{children:"Choosing the right graph representation is crucial for solving problems efficiently. Different modeling approaches have distinct trade-offs in terms of space complexity, time complexity, and ease of implementation."}),"\n",(0,i.jsx)(n.h3,{id:"1-adjacency-matrix",children:"1. Adjacency Matrix"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Best for"}),": Dense graphs, frequent edge existence checks, small graphs"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# For graph with n vertices\nadj_matrix = [[0] * n for _ in range(n)]\n\n# Add edge from i to j\nadj_matrix[i][j] = 1  # or weight for weighted graphs\n\n# Check if edge exists\nif adj_matrix[i][j]:\n    print("Edge exists")\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pros"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"O(1) edge lookup and modification"}),"\n",(0,i.jsx)(n.li,{children:"Simple implementation"}),"\n",(0,i.jsx)(n.li,{children:"Easy to check connectivity"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Cons"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"O(V\xb2) space complexity"}),"\n",(0,i.jsx)(n.li,{children:"Inefficient for sparse graphs"}),"\n",(0,i.jsx)(n.li,{children:"Memory waste for graphs with few edges"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Dense graphs (many edges relative to vertices)"}),"\n",(0,i.jsx)(n.li,{children:"Frequent edge existence queries"}),"\n",(0,i.jsx)(n.li,{children:"Small graphs where space isn't a concern"}),"\n",(0,i.jsx)(n.li,{children:"Floyd-Warshall algorithm (all-pairs shortest path)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/network-delay-time/",children:"Floyd-Warshall problems"})," - Network Delay Time"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule/",children:"Small graph problems"})," - Course Schedule (for small course counts)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-adjacency-list",children:"2. Adjacency List"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Best for"}),": Sparse graphs, traversal-heavy problems, memory-constrained scenarios"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# For each vertex, store list of neighbors\nadj_list = [[] for _ in range(n)]\n\n# Add edge from i to j\nadj_list[i].append(j)\n\n# For weighted graphs\nadj_list[i].append((j, weight))\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pros"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"O(V + E) space complexity"}),"\n",(0,i.jsx)(n.li,{children:"Efficient for sparse graphs"}),"\n",(0,i.jsx)(n.li,{children:"Natural for traversal algorithms"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Cons"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"O(degree) edge lookup"}),"\n",(0,i.jsx)(n.li,{children:"More complex implementation"}),"\n",(0,i.jsx)(n.li,{children:"Slower edge existence checks"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Sparse graphs (few edges relative to vertices)"}),"\n",(0,i.jsx)(n.li,{children:"Traversal-heavy problems (DFS, BFS)"}),"\n",(0,i.jsx)(n.li,{children:"Memory-constrained environments"}),"\n",(0,i.jsx)(n.li,{children:"Most competitive programming problems"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/number-of-islands/",children:"Graph Traversal"})," - Number of Islands"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/word-ladder/",children:"Path Finding"})," - Word Ladder"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-level-order-traversal/",children:"Tree Problems"})," - Binary Tree Level Order"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-edge-list",children:"3. Edge List"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Best for"}),": Kruskal's MST algorithm, edge-centric problems"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Store all edges as tuples\nedges = [(u, v, weight) for u, v, weight in edge_data]\n\n# For unweighted graphs\nedges = [(u, v) for u, v in edge_data]\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pros"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Simple edge iteration"}),"\n",(0,i.jsx)(n.li,{children:"Natural for MST algorithms"}),"\n",(0,i.jsx)(n.li,{children:"Easy to sort by weight"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Cons"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"O(E) time for neighbor lookup"}),"\n",(0,i.jsx)(n.li,{children:"Not suitable for traversal"}),"\n",(0,i.jsx)(n.li,{children:"Inefficient for adjacency queries"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Kruskal's MST algorithm"}),"\n",(0,i.jsx)(n.li,{children:"Edge-centric problems"}),"\n",(0,i.jsx)(n.li,{children:"When you need to process all edges"}),"\n",(0,i.jsx)(n.li,{children:"Union-Find based algorithms"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/min-cost-to-connect-all-points/",children:"MST Problems"})," - Min Cost to Connect All Points"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/redundant-connection/",children:"Union-Find"})," - Redundant Connection"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"4-object-oriented-node-representation",children:"4. Object-Oriented Node Representation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Best for"}),": Complex node data, tree-like structures, when nodes have rich attributes"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class Node:\n    def __init__(self, value):\n        self.value = value\n        self.neighbors = []\n        # Additional data like weight, color, etc.\n        self.visited = False\n        self.distance = float('inf')\n    \n    def add_neighbor(self, node, weight=1):\n        self.neighbors.append((node, weight))\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Undirected Graph Implementation"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class UndirectedGraph:\n    def __init__(self):\n        self.nodes = {}\n        self.adj_list = {}\n    \n    def add_node(self, value):\n        if value not in self.nodes:\n            self.nodes[value] = Node(value)\n            self.adj_list[value] = []\n    \n    def add_edge(self, node1_val, node2_val, weight=1):\n        # Add edge in both directions\n        if node1_val in self.adj_list and node2_val in self.adj_list:\n            self.adj_list[node1_val].append((node2_val, weight))\n            self.adj_list[node2_val].append((node1_val, weight))\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Directed Graph Implementation"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class DirectedGraph:\n    def __init__(self):\n        self.nodes = {}\n        self.adj_list = {}\n    \n    def add_node(self, value):\n        if value not in self.nodes:\n            self.nodes[value] = Node(value)\n            self.adj_list[value] = []\n    \n    def add_edge(self, source_val, dest_val, weight=1):\n        # Add edge only in specified direction\n        if source_val in self.adj_list and dest_val in self.adj_list:\n            self.adj_list[source_val].append((dest_val, weight))\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Complex node attributes"}),"\n",(0,i.jsx)(n.li,{children:"Tree-like structures"}),"\n",(0,i.jsx)(n.li,{children:"When nodes need to store additional state"}),"\n",(0,i.jsx)(n.li,{children:"Object-oriented design patterns"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/validate-binary-search-tree/",children:"Tree Problems"})," - Validate Binary Search Tree"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/clone-graph/",children:"Complex Node Data"})," - Clone Graph"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"5-hash-map-representation",children:"5. Hash Map Representation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Best for"}),": String-based nodes, dynamic graphs, when node values are not integers"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# String-based adjacency list\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D'],\n    'C': ['A', 'D'],\n    'D': ['B', 'C']\n}\n\n# For weighted graphs\nweighted_graph = {\n    'A': [('B', 5), ('C', 3)],\n    'B': [('A', 5), ('D', 2)],\n    'C': [('A', 3), ('D', 1)],\n    'D': [('B', 2), ('C', 1)]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"String-based node identifiers"}),"\n",(0,i.jsx)(n.li,{children:"Dynamic graph construction"}),"\n",(0,i.jsx)(n.li,{children:"When node values are not sequential integers"}),"\n",(0,i.jsx)(n.li,{children:"Word-based problems"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/word-ladder/",children:"Word Problems"})," - Word Ladder"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/accounts-merge/",children:"String-based Graphs"})," - Accounts Merge"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"problem-specific-modeling-guidelines",children:"Problem-Specific Modeling Guidelines"}),"\n",(0,i.jsx)(n.h3,{id:"if-solving-problems-like-this-model-this-way",children:"If solving problems like this, model this way:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"\ud83d\udd04 Cycle Detection Problems"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use"}),": Adjacency List"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Why"}),": Need to traverse and mark visited nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Examples"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule/",children:"Course Schedule"}),", ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/redundant-connection/",children:"Redundant Connection"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"\ud83d\udee4\ufe0f Shortest Path Problems"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use"}),": Adjacency List with weights"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Why"}),": Efficient for Dijkstra's and BFS"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Examples"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/network-delay-time/",children:"Network Delay Time"}),", ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/cheapest-flights-within-k-stops/",children:"Cheapest Flights Within K Stops"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"\ud83c\udf33 Tree Problems"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use"}),": Object-oriented nodes or adjacency list"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Why"}),": Natural parent-child relationships"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Examples"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-level-order-traversal/",children:"Binary Tree Level Order"}),", ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/validate-binary-search-tree/",children:"Validate BST"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"\ud83d\udd17 Connectivity Problems"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use"}),": Adjacency List or Union-Find"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Why"}),": Need to traverse connected components"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Examples"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/number-of-islands/",children:"Number of Islands"}),", ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/friend-circles/",children:"Friend Circles"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"\ud83d\udcca MST Problems"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use"}),": Edge List for Kruskal's, Adjacency List for Prim's"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Why"}),": Different algorithms require different representations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Examples"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/min-cost-to-connect-all-points/",children:"Min Cost to Connect All Points"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"\ud83c\udfaf Topological Sort Problems"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use"}),": Adjacency List with in-degree tracking"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Why"}),": Need to process nodes based on dependencies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Examples"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule-ii/",children:"Course Schedule II"}),", ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/alien-dictionary/",children:"Alien Dictionary"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"graph-representation-comparison",children:"Graph Representation Comparison"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Representation"}),(0,i.jsx)(n.th,{children:"Space"}),(0,i.jsx)(n.th,{children:"Edge Lookup"}),(0,i.jsx)(n.th,{children:"Add Edge"}),(0,i.jsx)(n.th,{children:"Traversal"}),(0,i.jsx)(n.th,{children:"Best For"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Adjacency Matrix"}),(0,i.jsx)(n.td,{children:"O(V\xb2)"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(V\xb2)"}),(0,i.jsx)(n.td,{children:"Dense graphs, small graphs"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Adjacency List"}),(0,i.jsx)(n.td,{children:"O(V + E)"}),(0,i.jsx)(n.td,{children:"O(degree)"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(V + E)"}),(0,i.jsx)(n.td,{children:"Sparse graphs, traversal"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Edge List"}),(0,i.jsx)(n.td,{children:"O(E)"}),(0,i.jsx)(n.td,{children:"O(E)"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(E)"}),(0,i.jsx)(n.td,{children:"MST algorithms"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Object Nodes"}),(0,i.jsx)(n.td,{children:"O(V + E)"}),(0,i.jsx)(n.td,{children:"O(degree)"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(V + E)"}),(0,i.jsx)(n.td,{children:"Complex node data"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Hash Map"}),(0,i.jsx)(n.td,{children:"O(V + E)"}),(0,i.jsx)(n.td,{children:"O(degree)"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(V + E)"}),(0,i.jsx)(n.td,{children:"String nodes, dynamic"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"quick-decision-guide",children:"Quick Decision Guide"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Choose Adjacency Matrix when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Graph is dense (E \u2248 V\xb2)"}),"\n",(0,i.jsx)(n.li,{children:"Frequent edge existence checks"}),"\n",(0,i.jsx)(n.li,{children:"Small number of vertices (< 1000)"}),"\n",(0,i.jsx)(n.li,{children:"Need O(1) edge operations"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Choose Adjacency List when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Graph is sparse (E ","<<"," V\xb2)"]}),"\n",(0,i.jsx)(n.li,{children:"Traversal-heavy problems"}),"\n",(0,i.jsx)(n.li,{children:"Memory is a concern"}),"\n",(0,i.jsx)(n.li,{children:"Most competitive programming problems"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Choose Edge List when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Using Kruskal's MST algorithm"}),"\n",(0,i.jsx)(n.li,{children:"Edge-centric operations"}),"\n",(0,i.jsx)(n.li,{children:"Need to sort edges by weight"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Choose Object Nodes when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Nodes have complex attributes"}),"\n",(0,i.jsx)(n.li,{children:"Tree-like structures"}),"\n",(0,i.jsx)(n.li,{children:"Need to store additional state"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Choose Hash Map when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Node values are strings"}),"\n",(0,i.jsx)(n.li,{children:"Dynamic graph construction"}),"\n",(0,i.jsx)(n.li,{children:"Non-integer node identifiers"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"essential-graph-algorithms",children:"Essential Graph Algorithms"}),"\n",(0,i.jsx)(n.p,{children:"Understanding when to use which graph algorithm is crucial for solving problems efficiently. Each algorithm has specific use cases and optimal scenarios."}),"\n",(0,i.jsx)(n.h2,{id:"cycle-detection-algorithms",children:"Cycle Detection Algorithms"}),"\n",(0,i.jsx)(n.p,{children:"Cycle detection is a fundamental problem in graph theory with applications in dependency resolution, deadlock detection, and network analysis."}),"\n",(0,i.jsx)(n.h3,{id:"1-dfs-based-cycle-detection",children:"1. DFS-based Cycle Detection"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": General cycle detection, directed graphs\n",(0,i.jsx)(n.strong,{children:"Time Complexity"}),": O(V + E)\n",(0,i.jsx)(n.strong,{children:"Space Complexity"}),": O(V)"]}),"\n",(0,i.jsx)(n.h4,{id:"directed-graph-cycle-detection",children:"Directed Graph Cycle Detection"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def has_cycle_directed(graph):\n    WHITE, GRAY, BLACK = 0, 1, 2\n    color = {vertex: WHITE for vertex in graph}\n    \n    def dfs(vertex):\n        if color[vertex] == GRAY:  # Back edge - cycle detected\n            return True\n        if color[vertex] == BLACK:  # Already processed\n            return False\n        \n        color[vertex] = GRAY\n        for neighbor in graph[vertex]:\n            if dfs(neighbor):\n                return True\n        color[vertex] = BLACK\n        return False\n    \n    for vertex in graph:\n        if color[vertex] == WHITE:\n            if dfs(vertex):\n                return True\n    return False\n"})}),"\n",(0,i.jsx)(n.h4,{id:"undirected-graph-cycle-detection",children:"Undirected Graph Cycle Detection"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def has_cycle_undirected(graph):\n    visited = set()\n    \n    def dfs(vertex, parent):\n        visited.add(vertex)\n        \n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                if dfs(neighbor, vertex):\n                    return True\n            elif neighbor != parent:  # Back edge to non-parent\n                return True\n        \n        return False\n    \n    for vertex in graph:\n        if vertex not in visited:\n            if dfs(vertex, -1):\n                return True\n    return False\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule/",children:"Course Schedule"})," - Directed cycle detection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/graph-valid-tree/",children:"Graph Valid Tree"})," - Undirected cycle detection"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-tarjans-strongly-connected-components-scc",children:"2. Tarjan's Strongly Connected Components (SCC)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": Finding all cycles, strongly connected components, network analysis\n",(0,i.jsx)(n.strong,{children:"Time Complexity"}),": O(V + E)\n",(0,i.jsx)(n.strong,{children:"Space Complexity"}),": O(V)"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def tarjan_scc(graph):\n    index = 0\n    stack = []\n    indices = {}\n    lowlinks = {}\n    on_stack = set()\n    sccs = []\n    \n    def strongconnect(vertex):\n        nonlocal index\n        indices[vertex] = index\n        lowlinks[vertex] = index\n        index += 1\n        stack.append(vertex)\n        on_stack.add(vertex)\n        \n        for neighbor in graph[vertex]:\n            if neighbor not in indices:\n                strongconnect(neighbor)\n                lowlinks[vertex] = min(lowlinks[vertex], lowlinks[neighbor])\n            elif neighbor in on_stack:\n                lowlinks[vertex] = min(lowlinks[vertex], indices[neighbor])\n        \n        if lowlinks[vertex] == indices[vertex]:\n            scc = []\n            while True:\n                w = stack.pop()\n                on_stack.remove(w)\n                scc.append(w)\n                if w == vertex:\n                    break\n            sccs.append(scc)\n    \n    for vertex in graph:\n        if vertex not in indices:\n            strongconnect(vertex)\n    \n    return sccs\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Features of Tarjan's Algorithm"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single Pass"}),": Finds all SCCs in one traversal"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lowlink Values"}),": Tracks the earliest reachable vertex"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stack-based"}),": Uses stack to maintain current path"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cycle Detection"}),": SCCs with size > 1 contain cycles"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/critical-connections-in-a-network/",children:"Critical Connections"})," - Bridge detection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/accounts-merge/",children:"Accounts Merge"})," - Connected components"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-union-find-cycle-detection",children:"3. Union-Find Cycle Detection"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": Undirected graphs, incremental edge addition\n",(0,i.jsx)(n.strong,{children:"Time Complexity"}),": O(E \xd7 \u03b1(V)) where \u03b1 is inverse Ackermann function\n",(0,i.jsx)(n.strong,{children:"Space Complexity"}),": O(V)"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return False  # Cycle detected\n        \n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n        return True\n\ndef has_cycle_union_find(edges, n):\n    uf = UnionFind(n)\n    \n    for u, v in edges:\n        if not uf.union(u, v):\n            return True  # Cycle detected\n    \n    return False\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/redundant-connection/",children:"Redundant Connection"})," - Union-Find cycle detection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/",children:"Number of Connected Components"})," - Component counting"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"4-kahns-algorithm-topological-sort",children:"4. Kahn's Algorithm (Topological Sort)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": Directed acyclic graph validation, dependency resolution\n",(0,i.jsx)(n.strong,{children:"Time Complexity"}),": O(V + E)\n",(0,i.jsx)(n.strong,{children:"Space Complexity"}),": O(V)"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def has_cycle_kahn(graph):\n    in_degree = {vertex: 0 for vertex in graph}\n    \n    # Calculate in-degrees\n    for vertex in graph:\n        for neighbor in graph[vertex]:\n            in_degree[neighbor] += 1\n    \n    # Find vertices with no incoming edges\n    queue = [vertex for vertex in in_degree if in_degree[vertex] == 0]\n    processed = 0\n    \n    while queue:\n        vertex = queue.pop(0)\n        processed += 1\n        \n        for neighbor in graph[vertex]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # If not all vertices processed, there's a cycle\n    return processed != len(graph)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule/",children:"Course Schedule"})," - DAG validation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule-ii/",children:"Course Schedule II"})," - Topological ordering"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"cycle-detection-problem-patterns",children:"Cycle Detection Problem Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"pattern-1-dependency-cycle-detection",children:"Pattern 1: Dependency Cycle Detection"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": Course prerequisites, build systems, task scheduling\n",(0,i.jsx)(n.strong,{children:"Approach"}),": Use DFS with color coding or Kahn's algorithm"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def can_finish_courses(num_courses, prerequisites):\n    graph = {i: [] for i in range(num_courses)}\n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n    \n    WHITE, GRAY, BLACK = 0, 1, 2\n    color = [WHITE] * num_courses\n    \n    def dfs(course):\n        if color[course] == GRAY:\n            return False  # Cycle detected\n        if color[course] == BLACK:\n            return True\n        \n        color[course] = GRAY\n        for neighbor in graph[course]:\n            if not dfs(neighbor):\n                return False\n        color[course] = BLACK\n        return True\n    \n    for course in range(num_courses):\n        if color[course] == WHITE:\n            if not dfs(course):\n                return False\n    return True\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-2-undirected-graph-cycle-detection",children:"Pattern 2: Undirected Graph Cycle Detection"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": Tree validation, network topology, graph connectivity\n",(0,i.jsx)(n.strong,{children:"Approach"}),": Use DFS with parent tracking"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def is_valid_tree(n, edges):\n    if len(edges) != n - 1:\n        return False  # Not a tree (wrong number of edges)\n    \n    graph = {i: [] for i in range(n)}\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = set()\n    \n    def dfs(vertex, parent):\n        if vertex in visited:\n            return False  # Cycle detected\n        \n        visited.add(vertex)\n        for neighbor in graph[vertex]:\n            if neighbor != parent:\n                if not dfs(neighbor, vertex):\n                    return False\n        return True\n    \n    return dfs(0, -1) and len(visited) == n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-3-strongly-connected-components",children:"Pattern 3: Strongly Connected Components"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": Network analysis, social networks, web page links\n",(0,i.jsx)(n.strong,{children:"Approach"}),": Use Tarjan's algorithm or Kosaraju's algorithm"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def kosaraju_scc(graph):\n    # Step 1: Get finish times using DFS\n    visited = set()\n    finish_times = []\n    \n    def dfs1(vertex):\n        visited.add(vertex)\n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                dfs1(neighbor)\n        finish_times.append(vertex)\n    \n    for vertex in graph:\n        if vertex not in visited:\n            dfs1(vertex)\n    \n    # Step 2: Reverse graph\n    reversed_graph = {vertex: [] for vertex in graph}\n    for vertex in graph:\n        for neighbor in graph[vertex]:\n            reversed_graph[neighbor].append(vertex)\n    \n    # Step 3: DFS on reversed graph in reverse finish time order\n    visited = set()\n    sccs = []\n    \n    def dfs2(vertex, scc):\n        visited.add(vertex)\n        scc.append(vertex)\n        for neighbor in reversed_graph[vertex]:\n            if neighbor not in visited:\n                dfs2(neighbor, scc)\n    \n    for vertex in reversed(finish_times):\n        if vertex not in visited:\n            scc = []\n            dfs2(vertex, scc)\n            sccs.append(scc)\n    \n    return sccs\n"})}),"\n",(0,i.jsx)(n.h2,{id:"cycle-detection-algorithm-comparison",children:"Cycle Detection Algorithm Comparison"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Algorithm"}),(0,i.jsx)(n.th,{children:"Time Complexity"}),(0,i.jsx)(n.th,{children:"Space Complexity"}),(0,i.jsx)(n.th,{children:"Use Case"}),(0,i.jsx)(n.th,{children:"Cycle Type"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DFS Color Coding"}),(0,i.jsx)(n.td,{children:"O(V + E)"}),(0,i.jsx)(n.td,{children:"O(V)"}),(0,i.jsx)(n.td,{children:"General directed graphs"}),(0,i.jsx)(n.td,{children:"Directed cycles"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DFS Parent Tracking"}),(0,i.jsx)(n.td,{children:"O(V + E)"}),(0,i.jsx)(n.td,{children:"O(V)"}),(0,i.jsx)(n.td,{children:"Undirected graphs"}),(0,i.jsx)(n.td,{children:"Undirected cycles"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Tarjan's SCC"}),(0,i.jsx)(n.td,{children:"O(V + E)"}),(0,i.jsx)(n.td,{children:"O(V)"}),(0,i.jsx)(n.td,{children:"Strongly connected components"}),(0,i.jsx)(n.td,{children:"All cycles in SCCs"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Union-Find"}),(0,i.jsx)(n.td,{children:"O(E \xd7 \u03b1(V))"}),(0,i.jsx)(n.td,{children:"O(V)"}),(0,i.jsx)(n.td,{children:"Undirected graphs, incremental"}),(0,i.jsx)(n.td,{children:"Undirected cycles"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Kahn's Algorithm"}),(0,i.jsx)(n.td,{children:"O(V + E)"}),(0,i.jsx)(n.td,{children:"O(V)"}),(0,i.jsx)(n.td,{children:"DAG validation"}),(0,i.jsx)(n.td,{children:"Directed cycles"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-each-cycle-detection-method",children:"When to Use Each Cycle Detection Method"}),"\n",(0,i.jsx)(n.h3,{id:"use-dfs-color-coding-when",children:"Use DFS Color Coding when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Detecting cycles in directed graphs"}),"\n",(0,i.jsx)(n.li,{children:"Need to find the first cycle encountered"}),"\n",(0,i.jsx)(n.li,{children:"General-purpose cycle detection"}),"\n",(0,i.jsx)(n.li,{children:"Simple implementation needed"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"use-tarjans-algorithm-when",children:"Use Tarjan's Algorithm when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Need all strongly connected components"}),"\n",(0,i.jsx)(n.li,{children:"Network analysis required"}),"\n",(0,i.jsx)(n.li,{children:"Finding all cycles in the graph"}),"\n",(0,i.jsx)(n.li,{children:"Advanced graph algorithms"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"use-union-find-when",children:"Use Union-Find when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Undirected graphs only"}),"\n",(0,i.jsx)(n.li,{children:"Incremental edge addition"}),"\n",(0,i.jsx)(n.li,{children:"Need to detect cycle as edges are added"}),"\n",(0,i.jsx)(n.li,{children:"Memory efficiency is important"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"use-kahns-algorithm-when",children:"Use Kahn's Algorithm when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Validating directed acyclic graphs"}),"\n",(0,i.jsx)(n.li,{children:"Dependency resolution"}),"\n",(0,i.jsx)(n.li,{children:"Topological sorting needed"}),"\n",(0,i.jsx)(n.li,{children:"Simple cycle detection in DAGs"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples by Pattern"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dependency Cycles"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule/",children:"Course Schedule"}),", ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule-ii/",children:"Course Schedule II"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Undirected Cycles"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/graph-valid-tree/",children:"Graph Valid Tree"}),", ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/redundant-connection/",children:"Redundant Connection"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Strongly Connected"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/critical-connections-in-a-network/",children:"Critical Connections"}),", ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/accounts-merge/",children:"Accounts Merge"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"1-topological-sort",children:"1. Topological Sort"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What it is"}),": An ordering of vertices in a directed acyclic graph (DAG) such that for every directed edge (u, v), vertex u comes before vertex v in the ordering."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Dependency resolution problems"}),"\n",(0,i.jsx)(n.li,{children:"Course scheduling with prerequisites"}),"\n",(0,i.jsx)(n.li,{children:"Build system dependency ordering"}),"\n",(0,i.jsx)(n.li,{children:"Task scheduling with dependencies"}),"\n",(0,i.jsx)(n.li,{children:"Compiler dependency analysis"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"dfs-based-topological-sort-kahns-algorithm",children:"DFS-based Topological Sort (Kahn's Algorithm)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def topological_sort_dfs(graph):\n    WHITE, GRAY, BLACK = 0, 1, 2\n    color = {vertex: WHITE for vertex in graph}\n    result = []\n    \n    def dfs(vertex):\n        if color[vertex] == GRAY:  # Back edge - cycle detected\n            return False\n        if color[vertex] == BLACK:  # Already processed\n            return True\n        \n        color[vertex] = GRAY\n        for neighbor in graph[vertex]:\n            if not dfs(neighbor):\n                return False\n        \n        color[vertex] = BLACK\n        result.append(vertex)  # Add to result after processing all dependencies\n        return True\n    \n    for vertex in graph:\n        if color[vertex] == WHITE:\n            if not dfs(vertex):\n                return None  # Cycle detected\n    \n    return result[::-1]  # Reverse to get topological order\n"})}),"\n",(0,i.jsx)(n.h4,{id:"bfs-based-topological-sort-kahns-algorithm",children:"BFS-based Topological Sort (Kahn's Algorithm)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from collections import deque\n\ndef topological_sort_bfs(graph):\n    # Calculate in-degrees\n    in_degree = {vertex: 0 for vertex in graph}\n    for vertex in graph:\n        for neighbor in graph[vertex]:\n            in_degree[neighbor] += 1\n    \n    # Find vertices with no incoming edges\n    queue = deque([vertex for vertex in in_degree if in_degree[vertex] == 0])\n    result = []\n    \n    while queue:\n        vertex = queue.popleft()\n        result.append(vertex)\n        \n        # Remove this vertex and update in-degrees\n        for neighbor in graph[vertex]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check if all vertices were processed (no cycle)\n    return result if len(result) == len(graph) else None\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule/",children:"Course Schedule"})," - Detect if courses can be completed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule-ii/",children:"Course Schedule II"})," - Find valid course order"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/alien-dictionary/",children:"Alien Dictionary"})," - Reconstruct alien language order"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/task-scheduler/",children:"Task Scheduler"})," - Schedule tasks with cooldown"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-strongly-connected-components-scc",children:"2. Strongly Connected Components (SCC)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What it is"}),": A maximal set of vertices such that every vertex in the set is reachable from every other vertex in the set."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Social network analysis (mutual connections)"}),"\n",(0,i.jsx)(n.li,{children:"Web page link analysis"}),"\n",(0,i.jsx)(n.li,{children:"Dependency analysis in complex systems"}),"\n",(0,i.jsx)(n.li,{children:"Network reliability analysis"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"tarjans-algorithm",children:"Tarjan's Algorithm"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def tarjan_scc(graph):\n    index = 0\n    stack = []\n    indices = {}\n    lowlinks = {}\n    on_stack = set()\n    sccs = []\n    \n    def strongconnect(vertex):\n        nonlocal index\n        indices[vertex] = index\n        lowlinks[vertex] = index\n        index += 1\n        stack.append(vertex)\n        on_stack.add(vertex)\n        \n        for neighbor in graph[vertex]:\n            if neighbor not in indices:\n                strongconnect(neighbor)\n                lowlinks[vertex] = min(lowlinks[vertex], lowlinks[neighbor])\n            elif neighbor in on_stack:\n                lowlinks[vertex] = min(lowlinks[vertex], indices[neighbor])\n        \n        if lowlinks[vertex] == indices[vertex]:\n            scc = []\n            while True:\n                w = stack.pop()\n                on_stack.remove(w)\n                scc.append(w)\n                if w == vertex:\n                    break\n            sccs.append(scc)\n    \n    for vertex in graph:\n        if vertex not in indices:\n            strongconnect(vertex)\n    \n    return sccs\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/critical-connections-in-a-network/",children:"Critical Connections"})," - Find bridge edges"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/accounts-merge/",children:"Accounts Merge"})," - Merge connected accounts"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-minimum-spanning-tree-mst",children:"3. Minimum Spanning Tree (MST)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What it is"}),": A subset of edges that connects all vertices with minimum total weight."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Network design (minimum cost to connect all nodes)"}),"\n",(0,i.jsx)(n.li,{children:"Clustering problems"}),"\n",(0,i.jsx)(n.li,{children:"Approximation algorithms for TSP"}),"\n",(0,i.jsx)(n.li,{children:"Network reliability optimization"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"kruskals-algorithm",children:"Kruskal's Algorithm"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return False\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n        return True\n\ndef kruskal_mst(edges, n):\n    edges.sort(key=lambda x: x[2])  # Sort by weight\n    uf = UnionFind(n)\n    mst = []\n    \n    for u, v, weight in edges:\n        if uf.union(u, v):\n            mst.append((u, v, weight))\n            if len(mst) == n - 1:\n                break\n    \n    return mst\n"})}),"\n",(0,i.jsx)(n.h4,{id:"prims-algorithm",children:"Prim's Algorithm"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import heapq\n\ndef prim_mst(graph, start):\n    mst = []\n    visited = {start}\n    edges = [(weight, start, neighbor) for neighbor, weight in graph[start]]\n    heapq.heapify(edges)\n    \n    while edges and len(visited) < len(graph):\n        weight, u, v = heapq.heappop(edges)\n        if v not in visited:\n            visited.add(v)\n            mst.append((u, v, weight))\n            for neighbor, w in graph[v]:\n                if neighbor not in visited:\n                    heapq.heappush(edges, (w, v, neighbor))\n    \n    return mst\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/min-cost-to-connect-all-points/",children:"Min Cost to Connect All Points"})," - MST with Manhattan distance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/connecting-cities-with-minimum-cost/",children:"Connecting Cities With Minimum Cost"})," - MST with given edges"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"4-shortest-path-algorithms",children:"4. Shortest Path Algorithms"}),"\n",(0,i.jsx)(n.h4,{id:"dijkstras-algorithm-single-source",children:"Dijkstra's Algorithm (Single Source)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": Non-negative edge weights, single source shortest path"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import heapq\n\ndef dijkstra(graph, start):\n    distances = {vertex: float('infinity') for vertex in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_vertex = heapq.heappop(pq)\n        \n        if current_distance > distances[current_vertex]:\n            continue\n            \n        for neighbor, weight in graph[current_vertex]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n"})}),"\n",(0,i.jsx)(n.h4,{id:"bellman-ford-algorithm",children:"Bellman-Ford Algorithm"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": Negative edge weights, detect negative cycles"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def bellman_ford(graph, start):\n    distances = {vertex: float('infinity') for vertex in graph}\n    distances[start] = 0\n    \n    # Relax edges V-1 times\n    for _ in range(len(graph) - 1):\n        for vertex in graph:\n            for neighbor, weight in graph[vertex]:\n                if distances[vertex] + weight < distances[neighbor]:\n                    distances[neighbor] = distances[vertex] + weight\n    \n    # Check for negative cycles\n    for vertex in graph:\n        for neighbor, weight in graph[vertex]:\n            if distances[vertex] + weight < distances[neighbor]:\n                return None  # Negative cycle detected\n    \n    return distances\n"})}),"\n",(0,i.jsx)(n.h4,{id:"floyd-warshall-algorithm",children:"Floyd-Warshall Algorithm"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": All-pairs shortest path, small graphs"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def floyd_warshall(graph):\n    n = len(graph)\n    dist = [[float('infinity')] * n for _ in range(n)]\n    \n    # Initialize distances\n    for i in range(n):\n        dist[i][i] = 0\n        for j, weight in graph[i]:\n            dist[i][j] = weight\n    \n    # Floyd-Warshall algorithm\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    \n    return dist\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/network-delay-time/",children:"Network Delay Time"})," - Dijkstra's algorithm"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/cheapest-flights-within-k-stops/",children:"Cheapest Flights Within K Stops"})," - Modified Dijkstra's"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/path-with-minimum-effort/",children:"Path With Minimum Effort"})," - Shortest path with effort"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"5-graph-coloring",children:"5. Graph Coloring"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What it is"}),": Assigning colors to vertices such that no two adjacent vertices have the same color."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Scheduling problems (no conflicts)"}),"\n",(0,i.jsx)(n.li,{children:"Register allocation in compilers"}),"\n",(0,i.jsx)(n.li,{children:"Map coloring problems"}),"\n",(0,i.jsx)(n.li,{children:"Resource allocation"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def graph_coloring(graph, num_colors):\n    colors = {}\n    \n    def is_safe(vertex, color):\n        for neighbor in graph[vertex]:\n            if neighbor in colors and colors[neighbor] == color:\n                return False\n        return True\n    \n    def color_graph(vertex):\n        if vertex >= len(graph):\n            return True\n        \n        for color in range(num_colors):\n            if is_safe(vertex, color):\n                colors[vertex] = color\n                if color_graph(vertex + 1):\n                    return True\n                colors[vertex] = -1\n        \n        return False\n    \n    return color_graph(0)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule/",children:"Course Schedule"})," - Bipartite graph detection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/is-graph-bipartite/",children:"Is Graph Bipartite?"})," - 2-coloring problem"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"algorithm-selection-guide",children:"Algorithm Selection Guide"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Problem Type"}),(0,i.jsx)(n.th,{children:"Best Algorithm"}),(0,i.jsx)(n.th,{children:"Time Complexity"}),(0,i.jsx)(n.th,{children:"When to Use"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Dependency Ordering"}),(0,i.jsx)(n.td,{children:"Topological Sort"}),(0,i.jsx)(n.td,{children:"O(V + E)"}),(0,i.jsx)(n.td,{children:"DAGs, prerequisites"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Strong Connectivity"}),(0,i.jsx)(n.td,{children:"Tarjan's SCC"}),(0,i.jsx)(n.td,{children:"O(V + E)"}),(0,i.jsx)(n.td,{children:"Mutual reachability"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Minimum Spanning Tree"}),(0,i.jsx)(n.td,{children:"Kruskal's/Prim's"}),(0,i.jsx)(n.td,{children:"O(E log E)"}),(0,i.jsx)(n.td,{children:"Network design"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Single Source Shortest Path"}),(0,i.jsx)(n.td,{children:"Dijkstra's"}),(0,i.jsx)(n.td,{children:"O((V + E) log V)"}),(0,i.jsx)(n.td,{children:"Non-negative weights"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"All Pairs Shortest Path"}),(0,i.jsx)(n.td,{children:"Floyd-Warshall"}),(0,i.jsx)(n.td,{children:"O(V\xb3)"}),(0,i.jsx)(n.td,{children:"Small graphs"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Graph Coloring"}),(0,i.jsx)(n.td,{children:"Backtracking"}),(0,i.jsx)(n.td,{children:"O(V^C)"}),(0,i.jsx)(n.td,{children:"Scheduling, conflicts"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"graph-traversal-algorithms",children:"Graph Traversal Algorithms"}),"\n",(0,i.jsx)(n.h3,{id:"1-depth-first-search-dfs",children:"1. Depth-First Search (DFS)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def dfs(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    \n    visited.add(start)\n    print(start)  # Process vertex\n    \n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Iterative DFS"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def dfs_iterative(graph, start):\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        vertex = stack.pop()\n        if vertex not in visited:\n            visited.add(vertex)\n            print(vertex)  # Process vertex\n            \n            for neighbor in graph[vertex]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-breadth-first-search-bfs",children:"2. Breadth-First Search (BFS)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    \n    while queue:\n        vertex = queue.popleft()\n        print(vertex)  # Process vertex\n        \n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"shortest-path-algorithms",children:"Shortest Path Algorithms"}),"\n",(0,i.jsx)(n.h3,{id:"1-dijkstras-algorithm",children:"1. Dijkstra's Algorithm"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import heapq\n\ndef dijkstra(graph, start):\n    distances = {vertex: float('infinity') for vertex in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_vertex = heapq.heappop(pq)\n        \n        if current_distance > distances[current_vertex]:\n            continue\n            \n        for neighbor, weight in graph[current_vertex]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-bellman-ford-algorithm",children:"2. Bellman-Ford Algorithm"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def bellman_ford(graph, start):\n    distances = {vertex: float('infinity') for vertex in graph}\n    distances[start] = 0\n    \n    # Relax edges V-1 times\n    for _ in range(len(graph) - 1):\n        for vertex in graph:\n            for neighbor, weight in graph[vertex]:\n                if distances[vertex] + weight < distances[neighbor]:\n                    distances[neighbor] = distances[vertex] + weight\n    \n    # Check for negative cycles\n    for vertex in graph:\n        for neighbor, weight in graph[vertex]:\n            if distances[vertex] + weight < distances[neighbor]:\n                return None  # Negative cycle detected\n    \n    return distances\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-floyd-warshall-algorithm",children:"3. Floyd-Warshall Algorithm"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def floyd_warshall(graph):\n    n = len(graph)\n    dist = [[float('infinity')] * n for _ in range(n)]\n    \n    # Initialize distances\n    for i in range(n):\n        dist[i][i] = 0\n        for j, weight in graph[i]:\n            dist[i][j] = weight\n    \n    # Floyd-Warshall algorithm\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    \n    return dist\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-graph-algorithms",children:"Advanced Graph Algorithms"}),"\n",(0,i.jsx)(n.h3,{id:"1-topological-sort-1",children:"1. Topological Sort"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def topological_sort(graph):\n    in_degree = {vertex: 0 for vertex in graph}\n    \n    # Calculate in-degrees\n    for vertex in graph:\n        for neighbor in graph[vertex]:\n            in_degree[neighbor] += 1\n    \n    # Find vertices with no incoming edges\n    queue = [vertex for vertex in in_degree if in_degree[vertex] == 0]\n    result = []\n    \n    while queue:\n        vertex = queue.pop(0)\n        result.append(vertex)\n        \n        for neighbor in graph[vertex]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result if len(result) == len(graph) else None\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-strongly-connected-components-tarjans",children:"2. Strongly Connected Components (Tarjan's)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def tarjan_scc(graph):\n    index = 0\n    stack = []\n    indices = {}\n    lowlinks = {}\n    on_stack = set()\n    sccs = []\n    \n    def strongconnect(vertex):\n        nonlocal index\n        indices[vertex] = index\n        lowlinks[vertex] = index\n        index += 1\n        stack.append(vertex)\n        on_stack.add(vertex)\n        \n        for neighbor in graph[vertex]:\n            if neighbor not in indices:\n                strongconnect(neighbor)\n                lowlinks[vertex] = min(lowlinks[vertex], lowlinks[neighbor])\n            elif neighbor in on_stack:\n                lowlinks[vertex] = min(lowlinks[vertex], indices[neighbor])\n        \n        if lowlinks[vertex] == indices[vertex]:\n            scc = []\n            while True:\n                w = stack.pop()\n                on_stack.remove(w)\n                scc.append(w)\n                if w == vertex:\n                    break\n            sccs.append(scc)\n    \n    for vertex in graph:\n        if vertex not in indices:\n            strongconnect(vertex)\n    \n    return sccs\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-minimum-spanning-tree-kruskals",children:"3. Minimum Spanning Tree (Kruskal's)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return False\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n        return True\n\ndef kruskal_mst(edges, n):\n    edges.sort(key=lambda x: x[2])  # Sort by weight\n    uf = UnionFind(n)\n    mst = []\n    \n    for u, v, weight in edges:\n        if uf.union(u, v):\n            mst.append((u, v, weight))\n            if len(mst) == n - 1:\n                break\n    \n    return mst\n"})}),"\n",(0,i.jsx)(n.h2,{id:"graph-problem-patterns",children:"Graph Problem Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"1-cycle-detection",children:"1. Cycle Detection"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def has_cycle_directed(graph):\n    WHITE, GRAY, BLACK = 0, 1, 2\n    color = {vertex: WHITE for vertex in graph}\n    \n    def dfs(vertex):\n        color[vertex] = GRAY\n        for neighbor in graph[vertex]:\n            if color[neighbor] == GRAY:\n                return True\n            if color[neighbor] == WHITE and dfs(neighbor):\n                return True\n        color[vertex] = BLACK\n        return False\n    \n    for vertex in graph:\n        if color[vertex] == WHITE:\n            if dfs(vertex):\n                return True\n    return False\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-bipartite-graph-detection",children:"2. Bipartite Graph Detection"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def is_bipartite(graph):\n    color = {}\n    \n    def dfs(vertex, c):\n        if vertex in color:\n            return color[vertex] == c\n        color[vertex] = c\n        for neighbor in graph[vertex]:\n            if not dfs(neighbor, 1 - c):\n                return False\n        return True\n    \n    for vertex in graph:\n        if vertex not in color:\n            if not dfs(vertex, 0):\n                return False\n    return True\n"})}),"\n",(0,i.jsx)(n.h2,{id:"common-graph-mistakes-to-avoid",children:"Common Graph Mistakes to Avoid"}),"\n",(0,i.jsxs)(n.p,{children:["\u274c ",(0,i.jsx)(n.strong,{children:"Not handling disconnected components"})," - may miss parts of the graph\n\u274c ",(0,i.jsx)(n.strong,{children:"Infinite loops in cycles"})," - not marking visited vertices\n\u274c ",(0,i.jsx)(n.strong,{children:"Wrong data structure choice"})," - adjacency matrix vs list\n\u274c ",(0,i.jsx)(n.strong,{children:"Not considering edge cases"})," - empty graphs, single vertices\n\u274c ",(0,i.jsx)(n.strong,{children:"Memory issues with large graphs"})," - not optimizing space complexity"]}),"\n",(0,i.jsx)(n.h2,{id:"graph-algorithm-complexity",children:"Graph Algorithm Complexity"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Algorithm"}),(0,i.jsx)(n.th,{children:"Time Complexity"}),(0,i.jsx)(n.th,{children:"Space Complexity"}),(0,i.jsx)(n.th,{children:"Use Case"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DFS/BFS"}),(0,i.jsx)(n.td,{children:"O(V + E)"}),(0,i.jsx)(n.td,{children:"O(V)"}),(0,i.jsx)(n.td,{children:"Traversal, connectivity"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Dijkstra"}),(0,i.jsx)(n.td,{children:"O((V + E) log V)"}),(0,i.jsx)(n.td,{children:"O(V)"}),(0,i.jsx)(n.td,{children:"Single-source shortest path"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Bellman-Ford"}),(0,i.jsx)(n.td,{children:"O(VE)"}),(0,i.jsx)(n.td,{children:"O(V)"}),(0,i.jsx)(n.td,{children:"Negative weights"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Floyd-Warshall"}),(0,i.jsx)(n.td,{children:"O(V\xb3)"}),(0,i.jsx)(n.td,{children:"O(V\xb2)"}),(0,i.jsx)(n.td,{children:"All-pairs shortest path"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Topological Sort"}),(0,i.jsx)(n.td,{children:"O(V + E)"}),(0,i.jsx)(n.td,{children:"O(V)"}),(0,i.jsx)(n.td,{children:"DAG ordering"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Kruskal MST"}),(0,i.jsx)(n.td,{children:"O(E log E)"}),(0,i.jsx)(n.td,{children:"O(V)"}),(0,i.jsx)(n.td,{children:"Minimum spanning tree"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"action-items",children:"Action Items"}),"\n",(0,i.jsx)(n.p,{children:"This section contains specific action items that readers can take to enhance their understanding or apply the concepts from this post:"}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(n.strong,{children:"Implement all major graph algorithms"}),": Build DFS, BFS, Dijkstra's, Bellman-Ford, Floyd-Warshall, and topological sort from scratch"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(n.strong,{children:"Solve 10 graph-based coding problems"}),': Practice with problems like "Course Schedule", "Word Ladder", "Network Delay Time", "Critical Connections", and "Redundant Connection"']}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(n.strong,{children:"Build a graph visualization tool"}),": Create a program that can visualize graphs and highlight the path taken by different algorithms"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(n.strong,{children:"Analyze real-world networks"}),": Use graph algorithms to analyze social networks, transportation systems, or web page relationships"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Implementation Notes:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Each action item should be specific and measurable"}),"\n",(0,i.jsx)(n.li,{children:"Include expected outcomes or deliverables"}),"\n",(0,i.jsx)(n.li,{children:"Consider different skill levels (beginner, intermediate, advanced)"}),"\n",(0,i.jsx)(n.li,{children:"Provide context for why each action item is valuable"}),"\n"]}),"\n",(0,i.jsxs)(r,{children:[(0,i.jsx)("summary",{children:"\ud83e\udd16 AI Metadata (Click to expand)"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# AI METADATA - DO NOT REMOVE OR MODIFY\n# AI_UPDATE_INSTRUCTIONS:\n# This content should be updated when new graph algorithms, modeling techniques, or problem-solving patterns emerge\n#\n# 1. SCAN_SOURCES: Monitor algorithm textbooks, competitive programming resources, LeetCode problem updates, and graph theory research\n# 2. EXTRACT_DATA: Look for new graph algorithms, modeling approaches, optimization strategies, and real-world applications\n# 3. UPDATE_CONTENT: Add new graph types, update algorithm implementations, include new LeetCode problems, expand modeling approaches\n# 4. VERIFY_CHANGES: Ensure all code examples compile and run correctly, verify algorithm complexity claims, test LeetCode links\n# 5. MAINTAIN_FORMAT: Preserve the "I need to..." format in Purpose section, keep action items specific and measurable\n#\n# CONTENT_PATTERNS:\n# - Graph types: Include visual ASCII representations, key properties, when to use, LeetCode examples\n# - Modeling approaches: Cover adjacency matrix/list, edge list, object-oriented, hash map representations\n# - Algorithms: Always include time/space complexity, implementation details, problem-specific guidelines\n# - Code examples: Use clear variable names, include comments, provide both recursive and iterative versions\n# - Problem patterns: Include both theoretical understanding and practical implementation with real examples\n#\n# DATA_SOURCES:\n# - Algorithm textbooks: Introduction to Algorithms (CLRS), Algorithm Design Manual, Kleinberg-Tardos\n# - Competitive programming: Codeforces graph problems, AtCoder network algorithms, TopCoder\n# - Coding platforms: LeetCode graph problems, HackerRank algorithms, GeeksforGeeks\n# - Research papers: Graph theory, network science, social network analysis\n# - University courses: Princeton algorithms, MIT 6.006, Stanford CS161\n#\n# UPDATE_TRIGGERS:\n# - New graph algorithms published in computer science literature\n# - Changes in competitive programming graph problem patterns\n# - New LeetCode graph problems with different difficulty levels\n# - Performance improvements in graph algorithm implementations\n# - New real-world applications of graph algorithms (social networks, recommendation systems)\n# - Updates to graph libraries and frameworks (NetworkX, igraph, etc.)\n#\n# FORMATTING_RULES:\n# - Use \u2705 and \u274c for good/bad examples consistently\n# - Include code blocks with proper syntax highlighting (python, markdown)\n# - Maintain table formatting for comparisons and algorithm selection guides\n# - Keep action items in checkbox format with implementation notes\n# - Use ASCII art for graph visualizations\n# - Include LeetCode links with descriptive text\n#\n# UPDATE_FREQUENCY: Monthly review for new LeetCode problems, quarterly review for algorithms, annual review for comprehensive updates\n'})})]})]})}function a(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);