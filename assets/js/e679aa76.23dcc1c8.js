"use strict";(globalThis.webpackChunkbytesofpurpose_blog=globalThis.webpackChunkbytesofpurpose_blog||[]).push([[46115],{28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>a});var r=s(96540);const i={},t=r.createContext(i);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(t.Provider,{value:n},e.children)}},62099:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>c,frontMatter:()=>l,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"mental-models/understanding-data-structs-and-algos/understanding-heaps","title":"Understanding Heaps: A Complete Mental Model for Data Structure Mastery and Problem-Solving","description":"A comprehensive guide covering heap types, operations, problem patterns (top-k, sliding window, median finding), and practical applications with real LeetCode examples.","source":"@site/docs/3-mental-models/1-understanding-data-structs-and-algos/understanding-heaps.mdx","sourceDirName":"3-mental-models/1-understanding-data-structs-and-algos","slug":"/mental-models/understanding-data-structs-and-algos/understanding-heaps","permalink":"/docs/mental-models/understanding-data-structs-and-algos/understanding-heaps","draft":false,"unlisted":false,"editUrl":"https://github.com/omars-lab/omars-lab.github.io/edit/master/bytesofpurpose-blog/docs/3-mental-models/1-understanding-data-structs-and-algos/understanding-heaps.mdx","tags":[{"inline":true,"label":"data-structures","permalink":"/docs/tags/data-structures"},{"inline":true,"label":"algorithms","permalink":"/docs/tags/algorithms"},{"inline":true,"label":"heaps","permalink":"/docs/tags/heaps"},{"inline":true,"label":"priority-queues","permalink":"/docs/tags/priority-queues"},{"inline":true,"label":"computer-science","permalink":"/docs/tags/computer-science"},{"inline":true,"label":"top-k","permalink":"/docs/tags/top-k"},{"inline":true,"label":"sliding-window","permalink":"/docs/tags/sliding-window"},{"inline":true,"label":"median-finding","permalink":"/docs/tags/median-finding"}],"version":"current","frontMatter":{"slug":"understanding-heaps","title":"Understanding Heaps: A Complete Mental Model for Data Structure Mastery and Problem-Solving","description":"A comprehensive guide covering heap types, operations, problem patterns (top-k, sliding window, median finding), and practical applications with real LeetCode examples.","authors":["oeid"],"tags":["data-structures","algorithms","heaps","priority-queues","computer-science","top-k","sliding-window","median-finding"],"date":"2025-01-31T10:00","draft":false},"sidebar":"tutorialSidebar","previous":{"title":"Understanding Graphs: A Complete Mental Model for Network Analysis, Algorithms, and Problem-Solving","permalink":"/docs/mental-models/understanding-data-structs-and-algos/understanding-graphs"},"next":{"title":"Understanding Lists: A Complete Mental Model for Sequential Data and Sorting Algorithms","permalink":"/docs/mental-models/understanding-data-structs-and-algos/understanding-lists"}}');var i=s(74848),t=s(28453);const l={slug:"understanding-heaps",title:"Understanding Heaps: A Complete Mental Model for Data Structure Mastery and Problem-Solving",description:"A comprehensive guide covering heap types, operations, problem patterns (top-k, sliding window, median finding), and practical applications with real LeetCode examples.",authors:["oeid"],tags:["data-structures","algorithms","heaps","priority-queues","computer-science","top-k","sliding-window","median-finding"],date:"2025-01-31T10:00",draft:!1},a="Understanding Heaps: A Complete Mental Model for Data Structure Mastery and Problem-Solving",d={},o=[{value:"Purpose",id:"purpose",level:2},{value:"What Are Heaps?",id:"what-are-heaps",level:2},{value:"Key Properties",id:"key-properties",level:3},{value:"Types of Heaps",id:"types-of-heaps",level:2},{value:"1. Min-Heap",id:"1-min-heap",level:3},{value:"2. Max-Heap",id:"2-max-heap",level:3},{value:"Core Operations",id:"core-operations",level:2},{value:"1. Insertion (Heapify Up)",id:"1-insertion-heapify-up",level:3},{value:"2. Deletion (Heapify Down)",id:"2-deletion-heapify-down",level:3},{value:"Practical Applications",id:"practical-applications",level:2},{value:"1. Priority Queues",id:"1-priority-queues",level:3},{value:"2. Heap Sort",id:"2-heap-sort",level:3},{value:"3. Finding Kth Largest Element",id:"3-finding-kth-largest-element",level:3},{value:"Common Heap Patterns",id:"common-heap-patterns",level:2},{value:"Pattern 1: Top K Elements",id:"pattern-1-top-k-elements",level:3},{value:"Pattern 2: Merge K Sorted Lists",id:"pattern-2-merge-k-sorted-lists",level:3},{value:"Advanced Heap Types and Applications",id:"advanced-heap-types-and-applications",level:2},{value:"1. Binary Heap (Standard Heap)",id:"1-binary-heap-standard-heap",level:3},{value:"2. Fibonacci Heap",id:"2-fibonacci-heap",level:3},{value:"3. Binomial Heap",id:"3-binomial-heap",level:3},{value:"4. Pairing Heap",id:"4-pairing-heap",level:3},{value:"5. Leftist Heap",id:"5-leftist-heap",level:3},{value:"Heap Problem Patterns",id:"heap-problem-patterns",level:2},{value:"Pattern 1: Top K Elements",id:"pattern-1-top-k-elements-1",level:3},{value:"Pattern 2: Sliding Window Maximum",id:"pattern-2-sliding-window-maximum",level:3},{value:"Pattern 3: Two Heaps (Median Finding)",id:"pattern-3-two-heaps-median-finding",level:3},{value:"Pattern 4: Merge K Sorted Lists",id:"pattern-4-merge-k-sorted-lists",level:3},{value:"Key Distinctions: Heaps vs Other Data Structures",id:"key-distinctions-heaps-vs-other-data-structures",level:2},{value:"Heaps vs Sorted Lists/Arrays",id:"heaps-vs-sorted-listsarrays",level:3},{value:"Key Differences",id:"key-differences",level:4},{value:"Visual Comparison",id:"visual-comparison",level:4},{value:"When to Use Each",id:"when-to-use-each",level:4},{value:"Heaps vs Binary Search Trees (BST)",id:"heaps-vs-binary-search-trees-bst",level:3},{value:"Key Differences",id:"key-differences-1",level:4},{value:"Visual Comparison",id:"visual-comparison-1",level:4},{value:"When to Use Each",id:"when-to-use-each-1",level:4},{value:"Heaps vs Hash Maps",id:"heaps-vs-hash-maps",level:3},{value:"Key Differences",id:"key-differences-2",level:4},{value:"When to Use Each",id:"when-to-use-each-2",level:4},{value:"Heaps vs Stacks/Queues",id:"heaps-vs-stacksqueues",level:3},{value:"Key Differences",id:"key-differences-3",level:4},{value:"When to Use Each",id:"when-to-use-each-3",level:4},{value:"Heap vs Other Data Structures",id:"heap-vs-other-data-structures",level:2},{value:"Implementation Considerations",id:"implementation-considerations",level:2},{value:"Array Representation",id:"array-representation",level:3},{value:"Memory Efficiency",id:"memory-efficiency",level:3},{value:"Common Mistakes to Avoid",id:"common-mistakes-to-avoid",level:2},{value:"Action Items",id:"action-items",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"understanding-heaps-a-complete-mental-model-for-data-structure-mastery-and-problem-solving",children:"Understanding Heaps: A Complete Mental Model for Data Structure Mastery and Problem-Solving"})}),"\n",(0,i.jsx)(n.p,{children:"A comprehensive guide covering heap types, operations, problem patterns (top-k, sliding window, median finding), and practical applications with real LeetCode examples."}),"\n",(0,i.jsx)(n.h2,{id:"purpose",children:"Purpose"}),"\n",(0,i.jsx)(n.p,{children:"This guide was created to address four critical needs:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"I need to understand heap fundamentals"}),": Learn the core properties, types, and characteristics of heap data structures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"I need to master heap operations"}),": Implement and understand insertion, deletion, and heapification processes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"I need to apply heaps practically"}),": Use heaps in real-world scenarios like priority queues and sorting algorithms"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"I need to solve heap-based problems"}),": Tackle coding challenges that require heap knowledge and optimization"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The goal is to transform confusion about heap data structures into clear, actionable understanding through structured learning and practical examples."}),"\n",(0,i.jsx)(n.h2,{id:"what-are-heaps",children:"What Are Heaps?"}),"\n",(0,i.jsxs)(n.p,{children:["A heap is a specialized tree-based data structure that satisfies the ",(0,i.jsx)(n.strong,{children:"heap property"}),". It's a complete binary tree where:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Min-Heap"}),": Parent nodes are always smaller than or equal to their children"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Max-Heap"}),": Parent nodes are always greater than or equal to their children"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"key-properties",children:"Key Properties"}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Complete Binary Tree"}),": All levels are filled except possibly the last level, which is filled from left to right\n\u2705 ",(0,i.jsx)(n.strong,{children:"Heap Property"}),": Maintains ordering relationship between parent and child nodes\n\u2705 ",(0,i.jsx)(n.strong,{children:"Efficient Operations"}),": Insertion and deletion in O(log n) time\n\u2705 ",(0,i.jsx)(n.strong,{children:"Root Access"}),": Always provides the minimum (min-heap) or maximum (max-heap) element"]}),"\n",(0,i.jsx)(n.h2,{id:"types-of-heaps",children:"Types of Heaps"}),"\n",(0,i.jsx)(n.h3,{id:"1-min-heap",children:"1. Min-Heap"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"        1\n       / \\\n      2   3\n     / \\ / \\\n    4  5 6  7\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Root is the smallest element"}),"\n",(0,i.jsx)(n.li,{children:"Parent \u2264 children"}),"\n",(0,i.jsx)(n.li,{children:"Used for priority queues where lower values = higher priority"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-max-heap",children:"2. Max-Heap"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"        7\n       / \\\n      6   5\n     / \\ / \\\n    4  3 2  1\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Root is the largest element"}),"\n",(0,i.jsx)(n.li,{children:"Parent \u2265 children"}),"\n",(0,i.jsx)(n.li,{children:"Used for finding maximum elements efficiently"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"core-operations",children:"Core Operations"}),"\n",(0,i.jsx)(n.h3,{id:"1-insertion-heapify-up",children:"1. Insertion (Heapify Up)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def insert(heap, value):\n    heap.append(value)  # Add to end\n    current = len(heap) - 1\n    \n    # Bubble up to maintain heap property\n    while current > 0:\n        parent = (current - 1) // 2\n        if heap[current] >= heap[parent]:  # For min-heap\n            break\n        heap[current], heap[parent] = heap[parent], heap[current]\n        current = parent\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-deletion-heapify-down",children:"2. Deletion (Heapify Down)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def extract_min(heap):\n    if not heap:\n        return None\n    \n    min_val = heap[0]\n    heap[0] = heap[-1]  # Move last element to root\n    heap.pop()\n    \n    # Bubble down to maintain heap property\n    current = 0\n    while True:\n        left_child = 2 * current + 1\n        right_child = 2 * current + 2\n        smallest = current\n        \n        if left_child < len(heap) and heap[left_child] < heap[smallest]:\n            smallest = left_child\n        if right_child < len(heap) and heap[right_child] < heap[smallest]:\n            smallest = right_child\n            \n        if smallest == current:\n            break\n            \n        heap[current], heap[smallest] = heap[smallest], heap[current]\n        current = smallest\n    \n    return min_val\n"})}),"\n",(0,i.jsx)(n.h2,{id:"practical-applications",children:"Practical Applications"}),"\n",(0,i.jsx)(n.h3,{id:"1-priority-queues",children:"1. Priority Queues"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class PriorityQueue:\n    def __init__(self):\n        self.heap = []\n    \n    def enqueue(self, item, priority):\n        self.heap.append((priority, item))\n        self._heapify_up(len(self.heap) - 1)\n    \n    def dequeue(self):\n        if not self.heap:\n            return None\n        return self.heap[0][1]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-heap-sort",children:"2. Heap Sort"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def heap_sort(arr):\n    # Build max heap\n    for i in range(len(arr) // 2 - 1, -1, -1):\n        heapify(arr, len(arr), i)\n    \n    # Extract elements one by one\n    for i in range(len(arr) - 1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]\n        heapify(arr, i, 0)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-finding-kth-largest-element",children:"3. Finding Kth Largest Element"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def find_kth_largest(nums, k):\n    # Use min-heap of size k\n    heap = []\n    \n    for num in nums:\n        if len(heap) < k:\n            heapq.heappush(heap, num)\n        elif num > heap[0]:\n            heapq.heapreplace(heap, num)\n    \n    return heap[0]\n"})}),"\n",(0,i.jsx)(n.h2,{id:"common-heap-patterns",children:"Common Heap Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"pattern-1-top-k-elements",children:"Pattern 1: Top K Elements"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def top_k_frequent(nums, k):\n    count = Counter(nums)\n    return [num for num, _ in count.most_common(k)]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-2-merge-k-sorted-lists",children:"Pattern 2: Merge K Sorted Lists"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def merge_k_lists(lists):\n    heap = []\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst.val, i, lst))\n    \n    dummy = ListNode(0)\n    current = dummy\n    \n    while heap:\n        val, i, node = heapq.heappop(heap)\n        current.next = node\n        current = current.next\n        \n        if node.next:\n            heapq.heappush(heap, (node.next.val, i, node.next))\n    \n    return dummy.next\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-heap-types-and-applications",children:"Advanced Heap Types and Applications"}),"\n",(0,i.jsx)(n.h3,{id:"1-binary-heap-standard-heap",children:"1. Binary Heap (Standard Heap)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Characteristics"}),": Complete binary tree, array-based implementation\n",(0,i.jsx)(n.strong,{children:"Use cases"}),": General-purpose priority queues, heap sort\n",(0,i.jsx)(n.strong,{children:"Pros"}),": Simple implementation, cache-friendly, O(log n) operations\n",(0,i.jsx)(n.strong,{children:"Cons"}),": No decrease key, no merge operation"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class BinaryHeap:\n    def __init__(self, heap_type='min'):\n        self.heap = []\n        self.heap_type = heap_type\n    \n    def parent(self, i):\n        return (i - 1) // 2\n    \n    def left_child(self, i):\n        return 2 * i + 1\n    \n    def right_child(self, i):\n        return 2 * i + 2\n    \n    def insert(self, key):\n        self.heap.append(key)\n        self._heapify_up(len(self.heap) - 1)\n    \n    def extract_min(self):\n        if not self.heap:\n            return None\n        if len(self.heap) == 1:\n            return self.heap.pop()\n        \n        root = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self._heapify_down(0)\n        return root\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/kth-largest-element-in-an-array/",children:"Kth Largest Element"})," - Min heap of size k"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/merge-k-sorted-lists/",children:"Merge k Sorted Lists"})," - Priority queue"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/find-median-from-data-stream/",children:"Find Median from Data Stream"})," - Two heaps"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-fibonacci-heap",children:"2. Fibonacci Heap"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Characteristics"}),": Collection of trees, amortized O(1) operations\n",(0,i.jsx)(n.strong,{children:"Use cases"}),": Dijkstra's algorithm, advanced graph algorithms\n",(0,i.jsx)(n.strong,{children:"Pros"}),": O(1) decrease key, O(1) merge, amortized O(log n) delete min\n",(0,i.jsx)(n.strong,{children:"Cons"}),": Complex implementation, high constant factors"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Advanced graph algorithms"}),"\n",(0,i.jsx)(n.li,{children:"When decrease key is frequently needed"}),"\n",(0,i.jsx)(n.li,{children:"Theoretical optimal performance required"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-binomial-heap",children:"3. Binomial Heap"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Characteristics"}),": Collection of binomial trees, merge operation\n",(0,i.jsx)(n.strong,{children:"Use cases"}),": Priority queues with merge operations\n",(0,i.jsx)(n.strong,{children:"Pros"}),": O(log n) merge, O(log n) operations\n",(0,i.jsx)(n.strong,{children:"Cons"}),": More complex than binary heap"]}),"\n",(0,i.jsx)(n.h3,{id:"4-pairing-heap",children:"4. Pairing Heap"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Characteristics"}),": Multi-way tree, simple implementation\n",(0,i.jsx)(n.strong,{children:"Use cases"}),": Experimental priority queues\n",(0,i.jsx)(n.strong,{children:"Pros"}),": Simple implementation, good practical performance\n",(0,i.jsx)(n.strong,{children:"Cons"}),": No proven amortized bounds"]}),"\n",(0,i.jsx)(n.h3,{id:"5-leftist-heap",children:"5. Leftist Heap"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Characteristics"}),": Binary tree with leftist property\n",(0,i.jsx)(n.strong,{children:"Use cases"}),": Priority queues with merge operations\n",(0,i.jsx)(n.strong,{children:"Pros"}),": O(log n) merge, simple implementation\n",(0,i.jsx)(n.strong,{children:"Cons"}),": Not cache-friendly"]}),"\n",(0,i.jsx)(n.h2,{id:"heap-problem-patterns",children:"Heap Problem Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"pattern-1-top-k-elements-1",children:"Pattern 1: Top K Elements"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": Finding k largest/smallest elements\n",(0,i.jsx)(n.strong,{children:"Approach"}),": Use min heap of size k for largest, max heap for smallest"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def find_k_largest(nums, k):\n    import heapq\n    heap = []\n    \n    for num in nums:\n        if len(heap) < k:\n            heapq.heappush(heap, num)\n        elif num > heap[0]:\n            heapq.heapreplace(heap, num)\n    \n    return heap[0]  # Kth largest\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/kth-largest-element-in-an-array/",children:"Kth Largest Element"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/top-k-frequent-elements/",children:"Top K Frequent Elements"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/top-k-frequent-words/",children:"Top K Frequent Words"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"pattern-2-sliding-window-maximum",children:"Pattern 2: Sliding Window Maximum"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": Finding maximum in sliding window\n",(0,i.jsx)(n.strong,{children:"Approach"}),": Use max heap or deque with heap properties"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def max_sliding_window(nums, k):\n    import heapq\n    result = []\n    heap = []\n    \n    for i in range(len(nums)):\n        # Add current element\n        heapq.heappush(heap, (-nums[i], i))\n        \n        # Remove elements outside window\n        while heap[0][1] <= i - k:\n            heapq.heappop(heap)\n        \n        # Add to result if window is complete\n        if i >= k - 1:\n            result.append(-heap[0][0])\n    \n    return result\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/sliding-window-maximum/",children:"Sliding Window Maximum"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/maximum-sum-of-subarray-of-size-k/",children:"Maximum Sum of Subarray of Size K"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"pattern-3-two-heaps-median-finding",children:"Pattern 3: Two Heaps (Median Finding)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": Finding median in streaming data\n",(0,i.jsx)(n.strong,{children:"Approach"}),": Use min heap for larger half, max heap for smaller half"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class MedianFinder:\n    def __init__(self):\n        self.small = []  # Max heap (use negative values)\n        self.large = []  # Min heap\n    \n    def addNum(self, num):\n        import heapq\n        \n        if len(self.small) == len(self.large):\n            heapq.heappush(self.large, -heapq.heappushpop(self.small, -num))\n        else:\n            heapq.heappush(self.small, -heapq.heappushpop(self.large, num))\n    \n    def findMedian(self):\n        if len(self.small) == len(self.large):\n            return (-self.small[0] + self.large[0]) / 2\n        else:\n            return self.large[0]\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/find-median-from-data-stream/",children:"Find Median from Data Stream"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/sliding-window-median/",children:"Sliding Window Median"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"pattern-4-merge-k-sorted-lists",children:"Pattern 4: Merge K Sorted Lists"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": Combining multiple sorted sequences\n",(0,i.jsx)(n.strong,{children:"Approach"}),": Use min heap to always get the smallest element"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def merge_k_lists(lists):\n    import heapq\n    \n    heap = []\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst.val, i, lst))\n    \n    dummy = ListNode(0)\n    current = dummy\n    \n    while heap:\n        val, i, node = heapq.heappop(heap)\n        current.next = node\n        current = current.next\n        \n        if node.next:\n            heapq.heappush(heap, (node.next.val, i, node.next))\n    \n    return dummy.next\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/merge-k-sorted-lists/",children:"Merge k Sorted Lists"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/merge-k-sorted-arrays/",children:"Merge k Sorted Arrays"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"key-distinctions-heaps-vs-other-data-structures",children:"Key Distinctions: Heaps vs Other Data Structures"}),"\n",(0,i.jsx)(n.p,{children:"Understanding the fundamental differences between heaps and other data structures is crucial for choosing the right approach to solve problems."}),"\n",(0,i.jsx)(n.h3,{id:"heaps-vs-sorted-listsarrays",children:"Heaps vs Sorted Lists/Arrays"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u274c Common Misconception"}),': "Heaps are just sorted lists with fancy operations"']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u2705 Reality"}),": Heaps maintain partial order, sorted lists maintain complete order"]}),"\n",(0,i.jsx)(n.h4,{id:"key-differences",children:"Key Differences"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"Heaps"}),(0,i.jsx)(n.th,{children:"Sorted Lists/Arrays"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Ordering"})}),(0,i.jsx)(n.td,{children:"Partial order (heap property)"}),(0,i.jsx)(n.td,{children:"Complete order (sorted)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Min/Max Access"})}),(0,i.jsx)(n.td,{children:"O(1) - always at root"}),(0,i.jsx)(n.td,{children:"O(1) - first/last element"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Insertion"})}),(0,i.jsx)(n.td,{children:"O(log n) - heapify up"}),(0,i.jsx)(n.td,{children:"O(n) - find position + shift"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Deletion"})}),(0,i.jsx)(n.td,{children:"O(log n) - heapify down"}),(0,i.jsx)(n.td,{children:"O(n) - shift elements"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Search"})}),(0,i.jsx)(n.td,{children:"O(n) - linear search"}),(0,i.jsx)(n.td,{children:"O(log n) - binary search"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Memory"})}),(0,i.jsx)(n.td,{children:"Contiguous array"}),(0,i.jsx)(n.td,{children:"Contiguous array"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Use Case"})}),(0,i.jsx)(n.td,{children:"Priority queues, streaming"}),(0,i.jsx)(n.td,{children:"Sorted data, range queries"})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"visual-comparison",children:"Visual Comparison"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Heap (Partial Order)"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"        1\n       / \\\n      2   3\n     / \\ / \\\n    4  5 6  7\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Property"}),": Parent \u2264 children (min-heap)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Access"}),": Min at root (O(1))"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Insert"}),": Add at end, bubble up (O(log n))"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Delete"}),": Replace root with last, bubble down (O(log n))"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Sorted Array (Complete Order)"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[1, 2, 3, 4, 5, 6, 7]\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Property"}),": arr[i] \u2264 arr[i+1] for all i"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Access"}),": Min at index 0, max at index n-1 (O(1))"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Insert"}),": Find position (O(log n)) + shift (O(n)) = O(n)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Delete"}),": Remove + shift (O(n))"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"when-to-use-each",children:"When to Use Each"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Heaps when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Need frequent min/max access"}),"\n",(0,i.jsx)(n.li,{children:"Insertions and deletions are common"}),"\n",(0,i.jsx)(n.li,{children:"Don't need sorted order for all elements"}),"\n",(0,i.jsx)(n.li,{children:"Priority queue operations"}),"\n",(0,i.jsx)(n.li,{children:"Streaming data processing"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Sorted Arrays when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Need binary search frequently"}),"\n",(0,i.jsx)(n.li,{children:"Range queries are common"}),"\n",(0,i.jsx)(n.li,{children:"Data is mostly static"}),"\n",(0,i.jsx)(n.li,{children:"Need complete sorted order"}),"\n",(0,i.jsx)(n.li,{children:"Memory efficiency is critical"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Heap Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/find-median-from-data-stream/",children:"Find Median from Data Stream"})," - Dynamic min/max"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sorted Array Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/search-in-rotated-sorted-array/",children:"Search in Rotated Sorted Array"})," - Binary search"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"heaps-vs-binary-search-trees-bst",children:"Heaps vs Binary Search Trees (BST)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u274c Common Misconception"}),': "Heaps and BSTs are the same - both are trees"']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u2705 Reality"}),": Heaps prioritize min/max access, BSTs prioritize search operations"]}),"\n",(0,i.jsx)(n.h4,{id:"key-differences-1",children:"Key Differences"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"Heaps"}),(0,i.jsx)(n.th,{children:"Binary Search Trees"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Primary Purpose"})}),(0,i.jsx)(n.td,{children:"Priority queue (min/max)"}),(0,i.jsx)(n.td,{children:"Search and retrieval"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Ordering"})}),(0,i.jsx)(n.td,{children:"Heap property (parent \u2264 children)"}),(0,i.jsx)(n.td,{children:"BST property (left < root < right)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Min/Max Access"})}),(0,i.jsx)(n.td,{children:"O(1) - always at root"}),(0,i.jsx)(n.td,{children:"O(log n) - traverse to leftmost/rightmost"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Search"})}),(0,i.jsx)(n.td,{children:"O(n) - linear search"}),(0,i.jsx)(n.td,{children:"O(log n) - binary search"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Insertion"})}),(0,i.jsx)(n.td,{children:"O(log n) - heapify up"}),(0,i.jsx)(n.td,{children:"O(log n) - find position"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Deletion"})}),(0,i.jsx)(n.td,{children:"O(log n) - heapify down"}),(0,i.jsx)(n.td,{children:"O(log n) - find + remove"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Height"})}),(0,i.jsx)(n.td,{children:"Always O(log n) - complete tree"}),(0,i.jsx)(n.td,{children:"O(log n) balanced, O(n) worst case"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Balancing"})}),(0,i.jsx)(n.td,{children:"Always balanced"}),(0,i.jsx)(n.td,{children:"May need rebalancing"})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"visual-comparison-1",children:"Visual Comparison"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Heap (Min-Heap)"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"        1\n       / \\\n      2   3\n     / \\ / \\\n    4  5 6  7\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Search for 5"}),": Must check all nodes (O(n))"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Get minimum"}),": Always at root (O(1))"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Insert 0"}),": Add at end, bubble up to root"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"BST (Balanced)"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"      4\n     / \\\n    2   6\n   / \\ / \\\n  1  3 5  7\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Search for 5"}),": Binary search (O(log n))"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Get minimum"}),": Traverse left (O(log n))"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Insert 0"}),": Find position, add as left child of 1"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"when-to-use-each-1",children:"When to Use Each"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Heaps when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Priority queue operations (min/max)"}),"\n",(0,i.jsx)(n.li,{children:"Don't need to search for specific values"}),"\n",(0,i.jsx)(n.li,{children:"Streaming data with priority"}),"\n",(0,i.jsx)(n.li,{children:"Heap sort"}),"\n",(0,i.jsx)(n.li,{children:"Top-k problems"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use BSTs when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Need to search for specific values"}),"\n",(0,i.jsx)(n.li,{children:"Range queries"}),"\n",(0,i.jsx)(n.li,{children:"Need sorted traversal"}),"\n",(0,i.jsx)(n.li,{children:"Dynamic data with search requirements"}),"\n",(0,i.jsx)(n.li,{children:"Balanced tree operations"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Heap Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/kth-largest-element-in-an-array/",children:"Kth Largest Element"})," - Priority queue"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"BST Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/validate-binary-search-tree/",children:"Validate Binary Search Tree"})," - Search property"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"heaps-vs-hash-maps",children:"Heaps vs Hash Maps"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u274c Common Misconception"}),': "Heaps are just hash maps with ordering"']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u2705 Reality"}),": Heaps maintain order, hash maps provide fast lookup"]}),"\n",(0,i.jsx)(n.h4,{id:"key-differences-2",children:"Key Differences"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"Heaps"}),(0,i.jsx)(n.th,{children:"Hash Maps"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Primary Purpose"})}),(0,i.jsx)(n.td,{children:"Priority queue (ordering)"}),(0,i.jsx)(n.td,{children:"Fast lookup (key-value)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Ordering"})}),(0,i.jsx)(n.td,{children:"\u2705 Maintains heap property"}),(0,i.jsx)(n.td,{children:"\u274c No inherent ordering"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Lookup"})}),(0,i.jsx)(n.td,{children:"O(n) - linear search"}),(0,i.jsx)(n.td,{children:"O(1) - hash lookup"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Min/Max"})}),(0,i.jsx)(n.td,{children:"O(1) - always at root"}),(0,i.jsx)(n.td,{children:"O(n) - must check all values"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Insertion"})}),(0,i.jsx)(n.td,{children:"O(log n) - heapify"}),(0,i.jsx)(n.td,{children:"O(1) - hash insert"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Deletion"})}),(0,i.jsx)(n.td,{children:"O(log n) - heapify"}),(0,i.jsx)(n.td,{children:"O(1) - hash delete"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Memory"})}),(0,i.jsx)(n.td,{children:"Contiguous array"}),(0,i.jsx)(n.td,{children:"Hash table with buckets"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Use Case"})}),(0,i.jsx)(n.td,{children:"Priority operations"}),(0,i.jsx)(n.td,{children:"Fast data retrieval"})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"when-to-use-each-2",children:"When to Use Each"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Heaps when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Need priority queue operations"}),"\n",(0,i.jsx)(n.li,{children:"Min/max access is frequent"}),"\n",(0,i.jsx)(n.li,{children:"Ordering is important"}),"\n",(0,i.jsx)(n.li,{children:"Streaming data processing"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Hash Maps when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fast lookup is critical"}),"\n",(0,i.jsx)(n.li,{children:"No ordering requirements"}),"\n",(0,i.jsx)(n.li,{children:"Key-value storage"}),"\n",(0,i.jsx)(n.li,{children:"Frequency counting"}),"\n",(0,i.jsx)(n.li,{children:"Caching"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Heap Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/top-k-frequent-elements/",children:"Top K Frequent Elements"})," - Priority queue"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hash Map Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/two-sum/",children:"Two Sum"})," - Fast lookup"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"heaps-vs-stacksqueues",children:"Heaps vs Stacks/Queues"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u274c Common Misconception"}),': "Heaps are just fancy stacks or queues"']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u2705 Reality"}),": Heaps provide priority-based access, stacks/queues provide position-based access"]}),"\n",(0,i.jsx)(n.h4,{id:"key-differences-3",children:"Key Differences"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"Heaps"}),(0,i.jsx)(n.th,{children:"Stacks"}),(0,i.jsx)(n.th,{children:"Queues"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Access Pattern"})}),(0,i.jsx)(n.td,{children:"Priority-based (min/max)"}),(0,i.jsx)(n.td,{children:"LIFO (last in, first out)"}),(0,i.jsx)(n.td,{children:"FIFO (first in, first out)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Ordering"})}),(0,i.jsx)(n.td,{children:"Heap property"}),(0,i.jsx)(n.td,{children:"Insertion order"}),(0,i.jsx)(n.td,{children:"Insertion order"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Min/Max Access"})}),(0,i.jsx)(n.td,{children:"O(1) - always at root"}),(0,i.jsx)(n.td,{children:"O(n) - must check all"}),(0,i.jsx)(n.td,{children:"O(n) - must check all"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Insertion"})}),(0,i.jsx)(n.td,{children:"O(log n) - heapify"}),(0,i.jsx)(n.td,{children:"O(1) - push to top"}),(0,i.jsx)(n.td,{children:"O(1) - enqueue to rear"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Deletion"})}),(0,i.jsx)(n.td,{children:"O(log n) - heapify"}),(0,i.jsx)(n.td,{children:"O(1) - pop from top"}),(0,i.jsx)(n.td,{children:"O(1) - dequeue from front"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Use Case"})}),(0,i.jsx)(n.td,{children:"Priority operations"}),(0,i.jsx)(n.td,{children:"Function calls, undo"}),(0,i.jsx)(n.td,{children:"BFS, scheduling"})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"when-to-use-each-3",children:"When to Use Each"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Heaps when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Priority-based operations needed"}),"\n",(0,i.jsx)(n.li,{children:"Min/max access is frequent"}),"\n",(0,i.jsx)(n.li,{children:"Ordering by value, not insertion time"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Stacks when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"LIFO behavior needed"}),"\n",(0,i.jsx)(n.li,{children:"Function call management"}),"\n",(0,i.jsx)(n.li,{children:"Undo operations"}),"\n",(0,i.jsx)(n.li,{children:"Expression evaluation"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Queues when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"FIFO behavior needed"}),"\n",(0,i.jsx)(n.li,{children:"BFS traversal"}),"\n",(0,i.jsx)(n.li,{children:"Task scheduling"}),"\n",(0,i.jsx)(n.li,{children:"Buffer management"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Heap Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/merge-k-sorted-lists/",children:"Merge k Sorted Lists"})," - Priority queue"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stack Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/valid-parentheses/",children:"Valid Parentheses"})," - LIFO"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Queue Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-level-order-traversal/",children:"Binary Tree Level Order"})," - FIFO"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"heap-vs-other-data-structures",children:"Heap vs Other Data Structures"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Operation"}),(0,i.jsx)(n.th,{children:"Heap"}),(0,i.jsx)(n.th,{children:"BST"}),(0,i.jsx)(n.th,{children:"Array"}),(0,i.jsx)(n.th,{children:"Sorted Array"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Insert"}),(0,i.jsx)(n.td,{children:"O(log n)"}),(0,i.jsx)(n.td,{children:"O(log n)"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(n)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Delete Min/Max"}),(0,i.jsx)(n.td,{children:"O(log n)"}),(0,i.jsx)(n.td,{children:"O(log n)"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(1)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Find Min/Max"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(log n)"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(1)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Merge"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(n)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Space"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(n)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Use Case"}),(0,i.jsx)(n.td,{children:"Priority Queue"}),(0,i.jsx)(n.td,{children:"Search"}),(0,i.jsx)(n.td,{children:"Simple"}),(0,i.jsx)(n.td,{children:"Sorted Data"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"implementation-considerations",children:"Implementation Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"array-representation",children:"Array Representation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Parent of node i: ",(0,i.jsx)(n.code,{children:"(i-1)/2"})]}),"\n",(0,i.jsxs)(n.li,{children:["Left child of node i: ",(0,i.jsx)(n.code,{children:"2*i + 1"})]}),"\n",(0,i.jsxs)(n.li,{children:["Right child of node i: ",(0,i.jsx)(n.code,{children:"2*i + 2"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"memory-efficiency",children:"Memory Efficiency"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Heaps can be implemented using arrays"}),"\n",(0,i.jsx)(n.li,{children:"No need for pointers (unlike BST)"}),"\n",(0,i.jsx)(n.li,{children:"Cache-friendly due to sequential memory access"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-mistakes-to-avoid",children:"Common Mistakes to Avoid"}),"\n",(0,i.jsxs)(n.p,{children:["\u274c ",(0,i.jsx)(n.strong,{children:"Forgetting to maintain heap property"})," after operations\n\u274c ",(0,i.jsx)(n.strong,{children:"Using wrong heap type"})," (min vs max) for the problem\n\u274c ",(0,i.jsx)(n.strong,{children:"Not handling edge cases"})," like empty heaps\n\u274c ",(0,i.jsx)(n.strong,{children:"Inefficient heap construction"})," (O(n log n) vs O(n))"]}),"\n",(0,i.jsx)(n.h2,{id:"action-items",children:"Action Items"}),"\n",(0,i.jsx)(n.p,{children:"This section contains specific action items that readers can take to enhance their understanding or apply the concepts from this post:"}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(n.strong,{children:"Implement a heap from scratch"}),": Build a complete heap data structure with insertion, deletion, and heapify operations in your preferred programming language"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(n.strong,{children:"Solve 5 heap-based coding problems"}),': Practice with problems like "Find Kth Largest Element", "Merge K Sorted Lists", "Top K Frequent Elements", "Sliding Window Maximum", and "Task Scheduler"']}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(n.strong,{children:"Compare heap implementations"}),": Implement the same heap operations using both array-based and tree-based approaches, then analyze their performance characteristics"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(n.strong,{children:"Build a priority queue application"}),": Create a real-world application (like a task scheduler or event system) that uses a priority queue to manage items by priority"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Implementation Notes:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Each action item should be specific and measurable"}),"\n",(0,i.jsx)(n.li,{children:"Include expected outcomes or deliverables"}),"\n",(0,i.jsx)(n.li,{children:"Consider different skill levels (beginner, intermediate, advanced)"}),"\n",(0,i.jsx)(n.li,{children:"Provide context for why each action item is valuable"}),"\n"]}),"\n",(0,i.jsxs)(s,{children:[(0,i.jsx)("summary",{children:"\ud83e\udd16 AI Metadata (Click to expand)"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# AI METADATA - DO NOT REMOVE OR MODIFY\n# AI_UPDATE_INSTRUCTIONS:\n# This content should be updated when new heap algorithms, problem patterns, or optimization techniques emerge\n#\n# 1. SCAN_SOURCES: Monitor algorithm textbooks, competitive programming resources, LeetCode heap problems, and heap research papers\n# 2. EXTRACT_DATA: Look for new heap types, problem patterns, optimization strategies, and real-world applications\n# 3. UPDATE_CONTENT: Add new heap types, update algorithm implementations, include new LeetCode problems, expand problem patterns\n# 4. VERIFY_CHANGES: Ensure all code examples compile and run correctly, verify algorithm complexity claims, test LeetCode links\n# 5. MAINTAIN_FORMAT: Preserve the "I need to..." format in Purpose section, keep action items specific and measurable\n#\n# CONTENT_PATTERNS:\n# - Heap types: Include characteristics, use cases, pros/cons, when to use each type\n# - Problem patterns: Cover top-k, sliding window, median finding, merge k sorted with examples\n# - Algorithm implementations: Always include time/space complexity, both recursive and iterative approaches\n# - Code examples: Use clear variable names, include comments, provide pattern templates\n# - Problem patterns: Include both theoretical understanding and practical implementation with real examples\n#\n# DATA_SOURCES:\n# - Algorithm textbooks: Introduction to Algorithms (CLRS), Algorithm Design Manual, Competitive Programming Handbook\n# - Competitive programming: Codeforces heap problems, AtCoder priority queue contests, TopCoder algorithm tutorials\n# - Coding platforms: LeetCode heap problems, HackerRank data structures, GeeksforGeeks heap section\n# - Research papers: Heap optimization techniques, advanced heap implementations, algorithmic improvements\n# - University courses: MIT 6.006, Stanford CS161, Princeton algorithms\n#\n# UPDATE_TRIGGERS:\n# - New heap algorithms published in computer science literature\n# - Changes in competitive programming heap problem patterns\n# - New LeetCode heap problems with different difficulty levels\n# - Performance improvements in heap implementations and priority queue optimizations\n# - New real-world applications of heap data structures (scheduling, resource allocation, streaming algorithms)\n# - Updates to heap libraries and frameworks\n#\n# FORMATTING_RULES:\n# - Use \u2705 and \u274c for good/bad examples consistently\n# - Include code blocks with proper syntax highlighting (python, markdown)\n# - Maintain table formatting for comparisons and algorithm selection guides\n# - Keep action items in checkbox format with implementation notes\n# - Include LeetCode links with descriptive text\n# - Use pattern templates for different heap problem types\n#\n# UPDATE_FREQUENCY: Monthly review for new LeetCode problems, quarterly review for algorithms, annual review for comprehensive updates\n'})})]})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);