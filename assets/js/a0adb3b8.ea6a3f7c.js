"use strict";(globalThis.webpackChunkbytesofpurpose_blog=globalThis.webpackChunkbytesofpurpose_blog||[]).push([[88940],{28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>a});var r=s(96540);const i={},t=r.createContext(i);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(t.Provider,{value:n},e.children)}},96717:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"mental-models/understanding-data-structs-and-algos/understanding-lists","title":"Understanding Lists: A Complete Mental Model for Sequential Data and Sorting Algorithms","description":"A comprehensive guide covering list types, representations, sorting algorithms (bubble, insertion, selection, merge, quick), and practical applications with real LeetCode examples.","source":"@site/docs/3-mental-models/1-understanding-data-structs-and-algos/understanding-lists.mdx","sourceDirName":"3-mental-models/1-understanding-data-structs-and-algos","slug":"/mental-models/understanding-data-structs-and-algos/understanding-lists","permalink":"/docs/mental-models/understanding-data-structs-and-algos/understanding-lists","draft":false,"unlisted":false,"editUrl":"https://github.com/omars-lab/omars-lab.github.io/edit/master/bytesofpurpose-blog/docs/3-mental-models/1-understanding-data-structs-and-algos/understanding-lists.mdx","tags":[{"inline":true,"label":"data-structures","permalink":"/docs/tags/data-structures"},{"inline":true,"label":"algorithms","permalink":"/docs/tags/algorithms"},{"inline":true,"label":"lists","permalink":"/docs/tags/lists"},{"inline":true,"label":"linked-lists","permalink":"/docs/tags/linked-lists"},{"inline":true,"label":"sorting","permalink":"/docs/tags/sorting"},{"inline":true,"label":"computer-science","permalink":"/docs/tags/computer-science"},{"inline":true,"label":"sequential-data","permalink":"/docs/tags/sequential-data"},{"inline":true,"label":"merge-sort","permalink":"/docs/tags/merge-sort"},{"inline":true,"label":"quick-sort","permalink":"/docs/tags/quick-sort"}],"version":"current","frontMatter":{"slug":"understanding-lists","title":"Understanding Lists: A Complete Mental Model for Sequential Data and Sorting Algorithms","description":"A comprehensive guide covering list types, representations, sorting algorithms (bubble, insertion, selection, merge, quick), and practical applications with real LeetCode examples.","authors":["oeid"],"tags":["data-structures","algorithms","lists","linked-lists","sorting","computer-science","sequential-data","merge-sort","quick-sort"],"date":"2025-01-31T10:00","draft":false},"sidebar":"tutorialSidebar","previous":{"title":"Understanding Heaps: A Complete Mental Model for Data Structure Mastery and Problem-Solving","permalink":"/docs/mental-models/understanding-data-structs-and-algos/understanding-heaps"},"next":{"title":"Understanding Trees: A Complete Mental Model for Hierarchical Data and Problem-Solving","permalink":"/docs/mental-models/understanding-data-structs-and-algos/understanding-trees"}}');var i=s(74848),t=s(28453);const l={slug:"understanding-lists",title:"Understanding Lists: A Complete Mental Model for Sequential Data and Sorting Algorithms",description:"A comprehensive guide covering list types, representations, sorting algorithms (bubble, insertion, selection, merge, quick), and practical applications with real LeetCode examples.",authors:["oeid"],tags:["data-structures","algorithms","lists","linked-lists","sorting","computer-science","sequential-data","merge-sort","quick-sort"],date:"2025-01-31T10:00",draft:!1},a="Understanding Lists: A Complete Mental Model for Sequential Data and Sorting Algorithms",d={},o=[{value:"Purpose",id:"purpose",level:2},{value:"What are Lists?",id:"what-are-lists",level:2},{value:"Key Properties",id:"key-properties",level:3},{value:"Types of Lists: A Comprehensive Classification",id:"types-of-lists-a-comprehensive-classification",level:2},{value:"1. Arrays vs Linked Lists",id:"1-arrays-vs-linked-lists",level:3},{value:"Arrays (Static Lists)",id:"arrays-static-lists",level:4},{value:"Linked Lists (Dynamic Lists)",id:"linked-lists-dynamic-lists",level:4},{value:"2. Singly vs Doubly Linked Lists",id:"2-singly-vs-doubly-linked-lists",level:3},{value:"Singly Linked List",id:"singly-linked-list",level:4},{value:"Doubly Linked List",id:"doubly-linked-list",level:4},{value:"3. Circular vs Linear Lists",id:"3-circular-vs-linear-lists",level:3},{value:"Circular Linked List",id:"circular-linked-list",level:4},{value:"Linear Linked List",id:"linear-linked-list",level:4},{value:"Core List Operations",id:"core-list-operations",level:2},{value:"1. Array Operations",id:"1-array-operations",level:3},{value:"2. Linked List Operations",id:"2-linked-list-operations",level:3},{value:"Sorting Algorithms for Lists",id:"sorting-algorithms-for-lists",level:2},{value:"1. Bubble Sort",id:"1-bubble-sort",level:3},{value:"2. Selection Sort",id:"2-selection-sort",level:3},{value:"3. Insertion Sort",id:"3-insertion-sort",level:3},{value:"4. Merge Sort",id:"4-merge-sort",level:3},{value:"5. Quick Sort",id:"5-quick-sort",level:3},{value:"6. Heap Sort",id:"6-heap-sort",level:3},{value:"List Problem Patterns",id:"list-problem-patterns",level:2},{value:"Pattern 1: Two Pointers",id:"pattern-1-two-pointers",level:3},{value:"Pattern 2: Sliding Window",id:"pattern-2-sliding-window",level:3},{value:"Pattern 3: Linked List Manipulation",id:"pattern-3-linked-list-manipulation",level:3},{value:"Pattern 4: Array Manipulation",id:"pattern-4-array-manipulation",level:3},{value:"Key Distinctions: Lists vs Other Data Structures",id:"key-distinctions-lists-vs-other-data-structures",level:2},{value:"Lists vs Arrays",id:"lists-vs-arrays",level:3},{value:"Key Differences",id:"key-differences",level:4},{value:"When to Use Each",id:"when-to-use-each",level:4},{value:"Lists vs Stacks/Queues",id:"lists-vs-stacksqueues",level:3},{value:"Key Differences",id:"key-differences-1",level:4},{value:"When to Use Each",id:"when-to-use-each-1",level:4},{value:"Lists vs Hash Maps",id:"lists-vs-hash-maps",level:3},{value:"Key Differences",id:"key-differences-2",level:4},{value:"When to Use Each",id:"when-to-use-each-2",level:4},{value:"Implementation Considerations",id:"implementation-considerations",level:2},{value:"Memory Management",id:"memory-management",level:3},{value:"Performance Trade-offs",id:"performance-trade-offs",level:3},{value:"Sorting Algorithm Selection",id:"sorting-algorithm-selection",level:3},{value:"Common Mistakes to Avoid",id:"common-mistakes-to-avoid",level:2},{value:"List vs Other Data Structures",id:"list-vs-other-data-structures",level:2},{value:"Action Items",id:"action-items",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"understanding-lists-a-complete-mental-model-for-sequential-data-and-sorting-algorithms",children:"Understanding Lists: A Complete Mental Model for Sequential Data and Sorting Algorithms"})}),"\n",(0,i.jsx)(n.p,{children:"A comprehensive guide covering list types, representations, sorting algorithms (bubble, insertion, selection, merge, quick), and practical applications with real LeetCode examples."}),"\n",(0,i.jsx)(n.h2,{id:"purpose",children:"Purpose"}),"\n",(0,i.jsx)(n.p,{children:"This guide was created to address four critical needs:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"I need to understand list fundamentals"}),": Learn the core properties, types, and characteristics of list data structures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"I need to master list operations"}),": Implement and understand insertion, deletion, traversal, and their variations for different problem types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"I need to apply lists practically"}),": Use lists in real-world scenarios like data storage, caching, and sequential processing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"I need to solve list-based problems"}),": Tackle coding challenges that require list knowledge and sorting algorithms"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The goal is to transform confusion about list data structures into clear, systematic problem-solving skills through structured learning and pattern recognition."}),"\n",(0,i.jsx)(n.h2,{id:"what-are-lists",children:"What are Lists?"}),"\n",(0,i.jsx)(n.p,{children:"A list is a linear data structure that stores elements in a sequential order, where each element can be accessed by its position (index)."}),"\n",(0,i.jsx)(n.h3,{id:"key-properties",children:"Key Properties"}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Sequential Access"}),": Elements stored in order\n\u2705 ",(0,i.jsx)(n.strong,{children:"Index-based"}),": Access elements by position\n\u2705 ",(0,i.jsx)(n.strong,{children:"Dynamic Size"}),": Can grow and shrink\n\u2705 ",(0,i.jsx)(n.strong,{children:"Homogeneous/Heterogeneous"}),": Can store same or different types\n\u2705 ",(0,i.jsx)(n.strong,{children:"Mutable"}),": Elements can be modified"]}),"\n",(0,i.jsx)(n.h2,{id:"types-of-lists-a-comprehensive-classification",children:"Types of Lists: A Comprehensive Classification"}),"\n",(0,i.jsx)(n.p,{children:"Understanding the different types of lists is crucial for choosing the right algorithms and data structures. Each type has unique properties that affect how we can traverse, analyze, and solve problems on them."}),"\n",(0,i.jsx)(n.h3,{id:"1-arrays-vs-linked-lists",children:"1. Arrays vs Linked Lists"}),"\n",(0,i.jsx)(n.h4,{id:"arrays-static-lists",children:"Arrays (Static Lists)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"arr = [1, 2, 3, 4, 5]\n# Memory: [1][2][3][4][5]\n# Index:   0  1  2  3  4\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Properties"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Contiguous memory allocation"}),"\n",(0,i.jsx)(n.li,{children:"Fixed size (static arrays)"}),"\n",(0,i.jsx)(n.li,{children:"Random access O(1)"}),"\n",(0,i.jsx)(n.li,{children:"Cache-friendly"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Known size requirements"}),"\n",(0,i.jsx)(n.li,{children:"Frequent random access"}),"\n",(0,i.jsx)(n.li,{children:"Performance-critical applications"}),"\n",(0,i.jsx)(n.li,{children:"Mathematical computations"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/two-sum/",children:"Two Sum"})," - Array traversal"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/maximum-subarray/",children:"Maximum Subarray"})," - Array processing"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"linked-lists-dynamic-lists",children:"Linked Lists (Dynamic Lists)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Node structure\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# Example: 1 -> 2 -> 3 -> 4 -> 5 -> None\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Properties"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Dynamic size"}),"\n",(0,i.jsx)(n.li,{children:"Sequential access O(n)"}),"\n",(0,i.jsx)(n.li,{children:"Memory efficient for sparse data"}),"\n",(0,i.jsx)(n.li,{children:"Easy insertion/deletion"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Unknown size requirements"}),"\n",(0,i.jsx)(n.li,{children:"Frequent insertions/deletions"}),"\n",(0,i.jsx)(n.li,{children:"Memory efficiency needed"}),"\n",(0,i.jsx)(n.li,{children:"Dynamic data structures"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/reverse-linked-list/",children:"Reverse Linked List"})," - Linked list manipulation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/merge-two-sorted-lists/",children:"Merge Two Sorted Lists"})," - List merging"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-singly-vs-doubly-linked-lists",children:"2. Singly vs Doubly Linked Lists"}),"\n",(0,i.jsx)(n.h4,{id:"singly-linked-list",children:"Singly Linked List"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# 1 -> 2 -> 3 -> 4 -> 5 -> None\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Properties"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"One pointer per node (next)"}),"\n",(0,i.jsx)(n.li,{children:"Forward traversal only"}),"\n",(0,i.jsx)(n.li,{children:"Less memory overhead"}),"\n",(0,i.jsx)(n.li,{children:"Simpler implementation"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Forward traversal only"}),"\n",(0,i.jsx)(n.li,{children:"Memory-constrained environments"}),"\n",(0,i.jsx)(n.li,{children:"Simple list operations"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/remove-duplicates-from-sorted-list/",children:"Remove Duplicates from Sorted List"})," - Forward traversal"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/linked-list-cycle/",children:"Linked List Cycle"})," - Cycle detection"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"doubly-linked-list",children:"Doubly Linked List"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class ListNode:\n    def __init__(self, val=0, prev=None, next=None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n\n# None <-> 1 <-> 2 <-> 3 <-> 4 <-> 5 <-> None\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Properties"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Two pointers per node (prev, next)"}),"\n",(0,i.jsx)(n.li,{children:"Bidirectional traversal"}),"\n",(0,i.jsx)(n.li,{children:"More memory overhead"}),"\n",(0,i.jsx)(n.li,{children:"Complex implementation"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Bidirectional traversal needed"}),"\n",(0,i.jsx)(n.li,{children:"LRU cache implementation"}),"\n",(0,i.jsx)(n.li,{children:"Complex list operations"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/lru-cache/",children:"LRU Cache"})," - Bidirectional access"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/design-linked-list/",children:"Design Linked List"})," - Full list operations"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-circular-vs-linear-lists",children:"3. Circular vs Linear Lists"}),"\n",(0,i.jsx)(n.h4,{id:"circular-linked-list",children:"Circular Linked List"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# 1 -> 2 -> 3 -> 4 -> 5 -> 1 (back to start)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Properties"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Last node points to first"}),"\n",(0,i.jsx)(n.li,{children:"No null termination"}),"\n",(0,i.jsx)(n.li,{children:"Useful for round-robin algorithms"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Round-robin scheduling"}),"\n",(0,i.jsx)(n.li,{children:"Circular buffers"}),"\n",(0,i.jsx)(n.li,{children:"Game mechanics"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"linear-linked-list",children:"Linear Linked List"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# 1 -> 2 -> 3 -> 4 -> 5 -> None\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Properties"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Last node points to None"}),"\n",(0,i.jsx)(n.li,{children:"Clear start and end"}),"\n",(0,i.jsx)(n.li,{children:"Standard list structure"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Most common use case"}),"\n",(0,i.jsx)(n.li,{children:"Standard list operations"}),"\n",(0,i.jsx)(n.li,{children:"Clear beginning and end"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"core-list-operations",children:"Core List Operations"}),"\n",(0,i.jsx)(n.h3,{id:"1-array-operations",children:"1. Array Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def array_operations():\n    # Creation\n    arr = [1, 2, 3, 4, 5]\n    \n    # Access\n    element = arr[2]  # O(1)\n    \n    # Insertion\n    arr.insert(2, 10)  # O(n) - shift elements\n    arr.append(6)      # O(1) - amortized\n    \n    # Deletion\n    arr.pop()          # O(1) - remove last\n    arr.pop(2)         # O(n) - shift elements\n    del arr[1]         # O(n) - shift elements\n    \n    # Search\n    index = arr.index(3)  # O(n) - linear search\n    \n    return arr\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-linked-list-operations",children:"2. Linked List Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class LinkedList:\n    def __init__(self):\n        self.head = None\n    \n    def insert_at_beginning(self, val):\n        new_node = ListNode(val)\n        new_node.next = self.head\n        self.head = new_node\n    \n    def insert_at_end(self, val):\n        new_node = ListNode(val)\n        if not self.head:\n            self.head = new_node\n            return\n        \n        current = self.head\n        while current.next:\n            current = current.next\n        current.next = new_node\n    \n    def delete(self, val):\n        if not self.head:\n            return\n        \n        if self.head.val == val:\n            self.head = self.head.next\n            return\n        \n        current = self.head\n        while current.next and current.next.val != val:\n            current = current.next\n        \n        if current.next:\n            current.next = current.next.next\n    \n    def search(self, val):\n        current = self.head\n        index = 0\n        while current:\n            if current.val == val:\n                return index\n            current = current.next\n            index += 1\n        return -1\n"})}),"\n",(0,i.jsx)(n.h2,{id:"sorting-algorithms-for-lists",children:"Sorting Algorithms for Lists"}),"\n",(0,i.jsx)(n.h3,{id:"1-bubble-sort",children:"1. Bubble Sort"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n    return arr\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Time Complexity"}),": O(n\xb2) worst case, O(n) best case\n",(0,i.jsx)(n.strong,{children:"Space Complexity"}),": O(1)\n",(0,i.jsx)(n.strong,{children:"Stable"}),": Yes\n",(0,i.jsx)(n.strong,{children:"Use case"}),": Educational purposes, small datasets"]}),"\n",(0,i.jsx)(n.h3,{id:"2-selection-sort",children:"2. Selection Sort"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Time Complexity"}),": O(n\xb2)\n",(0,i.jsx)(n.strong,{children:"Space Complexity"}),": O(1)\n",(0,i.jsx)(n.strong,{children:"Stable"}),": No\n",(0,i.jsx)(n.strong,{children:"Use case"}),": When write operations are expensive"]}),"\n",(0,i.jsx)(n.h3,{id:"3-insertion-sort",children:"3. Insertion Sort"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Time Complexity"}),": O(n\xb2) worst case, O(n) best case\n",(0,i.jsx)(n.strong,{children:"Space Complexity"}),": O(1)\n",(0,i.jsx)(n.strong,{children:"Stable"}),": Yes\n",(0,i.jsx)(n.strong,{children:"Use case"}),": Small datasets, nearly sorted data"]}),"\n",(0,i.jsx)(n.h3,{id:"4-merge-sort",children:"4. Merge Sort"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Time Complexity"}),": O(n log n)\n",(0,i.jsx)(n.strong,{children:"Space Complexity"}),": O(n)\n",(0,i.jsx)(n.strong,{children:"Stable"}),": Yes\n",(0,i.jsx)(n.strong,{children:"Use case"}),": General-purpose sorting, stable sort needed"]}),"\n",(0,i.jsx)(n.h3,{id:"5-quick-sort",children:"5. Quick Sort"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def quick_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    \n    return quick_sort(left) + middle + quick_sort(right)\n\n# In-place version\ndef quick_sort_inplace(arr, low, high):\n    if low < high:\n        pi = partition(arr, low, high)\n        quick_sort_inplace(arr, low, pi - 1)\n        quick_sort_inplace(arr, pi + 1, high)\n\ndef partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    \n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Time Complexity"}),": O(n log n) average, O(n\xb2) worst case\n",(0,i.jsx)(n.strong,{children:"Space Complexity"}),": O(log n)\n",(0,i.jsx)(n.strong,{children:"Stable"}),": No\n",(0,i.jsx)(n.strong,{children:"Use case"}),": General-purpose sorting, in-place sorting"]}),"\n",(0,i.jsx)(n.h3,{id:"6-heap-sort",children:"6. Heap Sort"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def heap_sort(arr):\n    n = len(arr)\n    \n    # Build max heap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    \n    # Extract elements one by one\n    for i in range(n - 1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]\n        heapify(arr, i, 0)\n    \n    return arr\n\ndef heapify(arr, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    \n    if left < n and arr[left] > arr[largest]:\n        largest = left\n    \n    if right < n and arr[right] > arr[largest]:\n        largest = right\n    \n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Time Complexity"}),": O(n log n)\n",(0,i.jsx)(n.strong,{children:"Space Complexity"}),": O(1)\n",(0,i.jsx)(n.strong,{children:"Stable"}),": No\n",(0,i.jsx)(n.strong,{children:"Use case"}),": In-place sorting, guaranteed O(n log n)"]}),"\n",(0,i.jsx)(n.h2,{id:"list-problem-patterns",children:"List Problem Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"pattern-1-two-pointers",children:"Pattern 1: Two Pointers"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": Finding pairs, removing duplicates, palindrome checking\n",(0,i.jsx)(n.strong,{children:"Approach"}),": Use two pointers moving at different speeds or directions"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def two_sum_sorted(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/",children:"Two Sum II - Input Array Is Sorted"})," - Two pointers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/remove-duplicates-from-sorted-array/",children:"Remove Duplicates from Sorted Array"})," - Duplicate removal"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/valid-palindrome/",children:"Valid Palindrome"})," - Palindrome checking"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"pattern-2-sliding-window",children:"Pattern 2: Sliding Window"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": Subarray problems, substring problems, fixed-size windows\n",(0,i.jsx)(n.strong,{children:"Approach"}),": Maintain a window and slide it across the array"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def max_sum_subarray(nums, k):\n    if len(nums) < k:\n        return 0\n    \n    window_sum = sum(nums[:k])\n    max_sum = window_sum\n    \n    for i in range(k, len(nums)):\n        window_sum = window_sum - nums[i - k] + nums[i]\n        max_sum = max(max_sum, window_sum)\n    \n    return max_sum\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/maximum-sum-subarray-of-size-k/",children:"Maximum Sum Subarray of Size K"})," - Fixed window"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/longest-substring-without-repeating-characters/",children:"Longest Substring Without Repeating Characters"})," - Variable window"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/sliding-window-maximum/",children:"Sliding Window Maximum"})," - Window with deque"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"pattern-3-linked-list-manipulation",children:"Pattern 3: Linked List Manipulation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": Reversing, merging, cycle detection, node manipulation\n",(0,i.jsx)(n.strong,{children:"Approach"}),": Use pointers to traverse and modify list structure"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def reverse_linked_list(head):\n    prev = None\n    current = head\n    \n    while current:\n        next_temp = current.next\n        current.next = prev\n        prev = current\n        current = next_temp\n    \n    return prev\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/reverse-linked-list/",children:"Reverse Linked List"})," - List reversal"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/merge-two-sorted-lists/",children:"Merge Two Sorted Lists"})," - List merging"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/linked-list-cycle/",children:"Linked List Cycle"})," - Cycle detection"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"pattern-4-array-manipulation",children:"Pattern 4: Array Manipulation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"When to use"}),": In-place operations, space optimization, array transformations\n",(0,i.jsx)(n.strong,{children:"Approach"}),": Use indices to track positions and perform operations"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def move_zeroes(nums):\n    write_index = 0\n    \n    for read_index in range(len(nums)):\n        if nums[read_index] != 0:\n            nums[write_index] = nums[read_index]\n            write_index += 1\n    \n    while write_index < len(nums):\n        nums[write_index] = 0\n        write_index += 1\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/move-zeroes/",children:"Move Zeroes"})," - In-place manipulation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/remove-element/",children:"Remove Element"})," - Element removal"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/rotate-array/",children:"Rotate Array"})," - Array rotation"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"key-distinctions-lists-vs-other-data-structures",children:"Key Distinctions: Lists vs Other Data Structures"}),"\n",(0,i.jsx)(n.p,{children:"Understanding the fundamental differences between lists and other data structures is crucial for choosing the right approach to solve problems."}),"\n",(0,i.jsx)(n.h3,{id:"lists-vs-arrays",children:"Lists vs Arrays"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u274c Common Misconception"}),': "Lists and arrays are the same thing"']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u2705 Reality"}),": Lists are a general concept, arrays are a specific implementation"]}),"\n",(0,i.jsx)(n.h4,{id:"key-differences",children:"Key Differences"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"Lists"}),(0,i.jsx)(n.th,{children:"Arrays"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),(0,i.jsx)(n.td,{children:"Abstract data type"}),(0,i.jsx)(n.td,{children:"Concrete data structure"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Memory"})}),(0,i.jsx)(n.td,{children:"Can be dynamic"}),(0,i.jsx)(n.td,{children:"Usually fixed size"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Implementation"})}),(0,i.jsx)(n.td,{children:"Can use arrays, linked lists"}),(0,i.jsx)(n.td,{children:"Contiguous memory"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Access"})}),(0,i.jsx)(n.td,{children:"Sequential or random"}),(0,i.jsx)(n.td,{children:"Random access O(1)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Flexibility"})}),(0,i.jsx)(n.td,{children:"High (dynamic size)"}),(0,i.jsx)(n.td,{children:"Low (fixed size)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Performance"})}),(0,i.jsx)(n.td,{children:"Variable"}),(0,i.jsx)(n.td,{children:"Predictable"})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"when-to-use-each",children:"When to Use Each"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Lists when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Dynamic size requirements"}),"\n",(0,i.jsx)(n.li,{children:"Frequent insertions/deletions"}),"\n",(0,i.jsx)(n.li,{children:"Unknown data size"}),"\n",(0,i.jsx)(n.li,{children:"Flexibility needed"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Arrays when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Known size requirements"}),"\n",(0,i.jsx)(n.li,{children:"Frequent random access"}),"\n",(0,i.jsx)(n.li,{children:"Performance-critical applications"}),"\n",(0,i.jsx)(n.li,{children:"Mathematical computations"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"List Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/design-linked-list/",children:"Design Linked List"})," - Dynamic list"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Array Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/two-sum/",children:"Two Sum"})," - Random access"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"lists-vs-stacksqueues",children:"Lists vs Stacks/Queues"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u274c Common Misconception"}),': "Lists are just stacks or queues with more operations"']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u2705 Reality"}),": Lists are general-purpose, stacks/queues are specialized with restricted access"]}),"\n",(0,i.jsx)(n.h4,{id:"key-differences-1",children:"Key Differences"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"Lists"}),(0,i.jsx)(n.th,{children:"Stacks"}),(0,i.jsx)(n.th,{children:"Queues"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Access Pattern"})}),(0,i.jsx)(n.td,{children:"Random/Sequential"}),(0,i.jsx)(n.td,{children:"LIFO (top only)"}),(0,i.jsx)(n.td,{children:"FIFO (front/rear)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Operations"})}),(0,i.jsx)(n.td,{children:"Full CRUD operations"}),(0,i.jsx)(n.td,{children:"Push, Pop, Peek"}),(0,i.jsx)(n.td,{children:"Enqueue, Dequeue, Front"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Use Case"})}),(0,i.jsx)(n.td,{children:"General data storage"}),(0,i.jsx)(n.td,{children:"Function calls, undo"}),(0,i.jsx)(n.td,{children:"BFS, scheduling"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Flexibility"})}),(0,i.jsx)(n.td,{children:"High"}),(0,i.jsx)(n.td,{children:"Low"}),(0,i.jsx)(n.td,{children:"Low"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Performance"})}),(0,i.jsx)(n.td,{children:"Variable"}),(0,i.jsx)(n.td,{children:"O(1) operations"}),(0,i.jsx)(n.td,{children:"O(1) operations"})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"when-to-use-each-1",children:"When to Use Each"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Lists when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"General data storage"}),"\n",(0,i.jsx)(n.li,{children:"Random access needed"}),"\n",(0,i.jsx)(n.li,{children:"Complex operations required"}),"\n",(0,i.jsx)(n.li,{children:"Flexibility needed"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Stacks when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"LIFO behavior needed"}),"\n",(0,i.jsx)(n.li,{children:"Function call management"}),"\n",(0,i.jsx)(n.li,{children:"Undo operations"}),"\n",(0,i.jsx)(n.li,{children:"Expression evaluation"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Queues when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"FIFO behavior needed"}),"\n",(0,i.jsx)(n.li,{children:"BFS traversal"}),"\n",(0,i.jsx)(n.li,{children:"Task scheduling"}),"\n",(0,i.jsx)(n.li,{children:"Buffer management"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"List Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/remove-duplicates-from-sorted-list/",children:"Remove Duplicates from Sorted List"})," - General list operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stack Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/valid-parentheses/",children:"Valid Parentheses"})," - LIFO operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Queue Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-level-order-traversal/",children:"Binary Tree Level Order Traversal"})," - FIFO operations"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"lists-vs-hash-maps",children:"Lists vs Hash Maps"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u274c Common Misconception"}),': "Lists are just hash maps with indices as keys"']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"\u2705 Reality"}),": Lists maintain order and allow duplicates, hash maps provide fast lookup"]}),"\n",(0,i.jsx)(n.h4,{id:"key-differences-2",children:"Key Differences"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"Lists"}),(0,i.jsx)(n.th,{children:"Hash Maps"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Ordering"})}),(0,i.jsx)(n.td,{children:"\u2705 Maintains order"}),(0,i.jsx)(n.td,{children:"\u274c No inherent ordering"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Duplicates"})}),(0,i.jsx)(n.td,{children:"\u2705 Allows duplicates"}),(0,i.jsx)(n.td,{children:"\u274c Unique keys only"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Access"})}),(0,i.jsx)(n.td,{children:"Index-based O(n)"}),(0,i.jsx)(n.td,{children:"Key-based O(1)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Memory"})}),(0,i.jsx)(n.td,{children:"Contiguous or linked"}),(0,i.jsx)(n.td,{children:"Hash table with buckets"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Use Case"})}),(0,i.jsx)(n.td,{children:"Sequential data"}),(0,i.jsx)(n.td,{children:"Fast lookups"})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"when-to-use-each-2",children:"When to Use Each"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Lists when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Order matters"}),"\n",(0,i.jsx)(n.li,{children:"Duplicates allowed"}),"\n",(0,i.jsx)(n.li,{children:"Sequential processing"}),"\n",(0,i.jsx)(n.li,{children:"Index-based access"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Hash Maps when"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fast lookup needed"}),"\n",(0,i.jsx)(n.li,{children:"Unique keys"}),"\n",(0,i.jsx)(n.li,{children:"No ordering requirements"}),"\n",(0,i.jsx)(n.li,{children:"Key-value storage"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"List Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/remove-duplicates-from-sorted-list/",children:"Remove Duplicates from Sorted List"})," - Ordered data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hash Map Problems"}),": ",(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/two-sum/",children:"Two Sum"})," - Fast lookup"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"implementation-considerations",children:"Implementation Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Arrays: Contiguous memory, cache-friendly"}),"\n",(0,i.jsx)(n.li,{children:"Linked Lists: Scattered memory, pointer overhead"}),"\n",(0,i.jsx)(n.li,{children:"Consider memory usage patterns"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"performance-trade-offs",children:"Performance Trade-offs"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Arrays: Fast random access, slow insertions/deletions"}),"\n",(0,i.jsx)(n.li,{children:"Linked Lists: Slow random access, fast insertions/deletions"}),"\n",(0,i.jsx)(n.li,{children:"Choose based on access patterns"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"sorting-algorithm-selection",children:"Sorting Algorithm Selection"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Small datasets: Insertion sort"}),"\n",(0,i.jsx)(n.li,{children:"General purpose: Merge sort (stable) or Quick sort (in-place)"}),"\n",(0,i.jsx)(n.li,{children:"Guaranteed O(n log n): Heap sort"}),"\n",(0,i.jsx)(n.li,{children:"Nearly sorted: Insertion sort"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-mistakes-to-avoid",children:"Common Mistakes to Avoid"}),"\n",(0,i.jsxs)(n.p,{children:["\u274c ",(0,i.jsx)(n.strong,{children:"Not handling edge cases"})," - Empty lists, single elements, null pointers\n\u274c ",(0,i.jsx)(n.strong,{children:"Off-by-one errors"})," - Array bounds, loop conditions\n\u274c ",(0,i.jsx)(n.strong,{children:"Memory leaks"})," - Not freeing linked list nodes\n\u274c ",(0,i.jsx)(n.strong,{children:"Inefficient algorithms"})," - Using O(n\xb2) when O(n log n) available\n\u274c ",(0,i.jsx)(n.strong,{children:"Wrong data structure choice"})," - Using lists when arrays or hash maps better"]}),"\n",(0,i.jsx)(n.h2,{id:"list-vs-other-data-structures",children:"List vs Other Data Structures"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Operation"}),(0,i.jsx)(n.th,{children:"List"}),(0,i.jsx)(n.th,{children:"Array"}),(0,i.jsx)(n.th,{children:"Hash Map"}),(0,i.jsx)(n.th,{children:"Stack"}),(0,i.jsx)(n.th,{children:"Queue"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Access"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(1)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Insert"}),(0,i.jsx)(n.td,{children:"O(1) to O(n)"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(1)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Delete"}),(0,i.jsx)(n.td,{children:"O(1) to O(n)"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(1)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Search"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(n)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Space"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(n)"}),(0,i.jsx)(n.td,{children:"O(n)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Use Case"}),(0,i.jsx)(n.td,{children:"General"}),(0,i.jsx)(n.td,{children:"Random Access"}),(0,i.jsx)(n.td,{children:"Lookup"}),(0,i.jsx)(n.td,{children:"LIFO"}),(0,i.jsx)(n.td,{children:"FIFO"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"action-items",children:"Action Items"}),"\n",(0,i.jsx)(n.p,{children:"This section contains specific action items that readers can take to enhance their understanding or apply the concepts from this post:"}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(n.strong,{children:"Implement all major sorting algorithms"}),": Build bubble sort, selection sort, insertion sort, merge sort, quick sort, and heap sort from scratch"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(n.strong,{children:"Solve 10 list-based coding problems"}),': Practice with problems like "Two Sum", "Remove Duplicates from Sorted List", "Reverse Linked List", "Merge Two Sorted Lists", and "Linked List Cycle"']}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(n.strong,{children:"Build a sorting algorithm visualizer"}),": Create a program that can visualize different sorting algorithms and compare their performance"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(n.strong,{children:"Master list manipulation patterns"}),": Practice two pointers, sliding window, and linked list manipulation techniques"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Implementation Notes:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Each action item should be specific and measurable"}),"\n",(0,i.jsx)(n.li,{children:"Include expected outcomes or deliverables"}),"\n",(0,i.jsx)(n.li,{children:"Consider different skill levels (beginner, intermediate, advanced)"}),"\n",(0,i.jsx)(n.li,{children:"Provide context for why each action item is valuable"}),"\n"]}),"\n",(0,i.jsxs)(s,{children:[(0,i.jsx)("summary",{children:"\ud83e\udd16 AI Metadata (Click to expand)"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# AI METADATA - DO NOT REMOVE OR MODIFY\n# AI_UPDATE_INSTRUCTIONS:\n# This content should be updated when new list algorithms, sorting techniques, or optimization methods emerge\n#\n# 1. SCAN_SOURCES: Monitor algorithm textbooks, competitive programming resources, LeetCode list problems, and sorting algorithm research\n# 2. EXTRACT_DATA: Look for new list types, sorting algorithms, optimization strategies, and real-world applications\n# 3. UPDATE_CONTENT: Add new list types, update algorithm implementations, include new LeetCode problems, expand sorting algorithms\n# 4. VERIFY_CHANGES: Ensure all code examples compile and run correctly, verify algorithm complexity claims, test LeetCode links\n# 5. MAINTAIN_FORMAT: Preserve the "I need to..." format in Purpose section, keep action items specific and measurable\n#\n# CONTENT_PATTERNS:\n# - List types: Include characteristics, use cases, pros/cons, when to use each type\n# - Sorting algorithms: Cover bubble, selection, insertion, merge, quick, heap sort with complexity analysis\n# - Problem patterns: Include two pointers, sliding window, linked list manipulation with examples\n# - Algorithm implementations: Always include time/space complexity, both recursive and iterative approaches\n# - Code examples: Use clear variable names, include comments, provide pattern templates\n# - Problem patterns: Include both theoretical understanding and practical implementation with real examples\n#\n# DATA_SOURCES:\n# - Algorithm textbooks: Introduction to Algorithms (CLRS), Algorithm Design Manual, Competitive Programming Handbook\n# - Competitive programming: Codeforces list problems, AtCoder sorting contests, TopCoder algorithm tutorials\n# - Coding platforms: LeetCode list problems, HackerRank data structures, GeeksforGeeks list section\n# - Research papers: Sorting algorithm optimizations, advanced list implementations, algorithmic improvements\n# - University courses: MIT 6.006, Stanford CS161, Princeton algorithms\n#\n# UPDATE_TRIGGERS:\n# - New sorting algorithms published in computer science literature\n# - Changes in competitive programming list problem patterns\n# - New LeetCode list problems with different difficulty levels\n# - Performance improvements in sorting implementations and optimizations\n# - New real-world applications of list data structures (databases, file systems, streaming)\n# - Updates to list libraries and frameworks\n#\n# FORMATTING_RULES:\n# - Use \u2705 and \u274c for good/bad examples consistently\n# - Include code blocks with proper syntax highlighting (python, markdown)\n# - Maintain table formatting for comparisons and algorithm selection guides\n# - Keep action items in checkbox format with implementation notes\n# - Include LeetCode links with descriptive text\n# - Use pattern templates for different list problem types\n#\n# UPDATE_FREQUENCY: Monthly review for new LeetCode problems, quarterly review for algorithms, annual review for comprehensive updates\n'})})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);