"use strict";(globalThis.webpackChunkbytesofpurpose_blog=globalThis.webpackChunkbytesofpurpose_blog||[]).push([[44156],{3459:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"mental-models/understanding-data-structs-and-algos/understanding-dynamic-programming","title":"Understanding Dynamic Programming: A Complete Mental Model for Algorithm Optimization and Problem-Solving","description":"A comprehensive guide covering DP fundamentals, problem types (1D, 2D, knapsack, interval, tree), optimization techniques, and practical problem-solving strategies with real LeetCode examples.","source":"@site/docs/3-mental-models/1-understanding-data-structs-and-algos/understanding-dynamic-programming.mdx","sourceDirName":"3-mental-models/1-understanding-data-structs-and-algos","slug":"/mental-models/understanding-data-structs-and-algos/understanding-dynamic-programming","permalink":"/docs/mental-models/understanding-data-structs-and-algos/understanding-dynamic-programming","draft":false,"unlisted":false,"editUrl":"https://github.com/omars-lab/omars-lab.github.io/edit/master/bytesofpurpose-blog/docs/3-mental-models/1-understanding-data-structs-and-algos/understanding-dynamic-programming.mdx","tags":[{"inline":true,"label":"algorithms","permalink":"/docs/tags/algorithms"},{"inline":true,"label":"dynamic-programming","permalink":"/docs/tags/dynamic-programming"},{"inline":true,"label":"optimization","permalink":"/docs/tags/optimization"},{"inline":true,"label":"problem-solving","permalink":"/docs/tags/problem-solving"},{"inline":true,"label":"computer-science","permalink":"/docs/tags/computer-science"},{"inline":true,"label":"knapsack","permalink":"/docs/tags/knapsack"},{"inline":true,"label":"memoization","permalink":"/docs/tags/memoization"},{"inline":true,"label":"tabulation","permalink":"/docs/tags/tabulation"}],"version":"current","frontMatter":{"slug":"understanding-dynamic-programming","title":"Understanding Dynamic Programming: A Complete Mental Model for Algorithm Optimization and Problem-Solving","description":"A comprehensive guide covering DP fundamentals, problem types (1D, 2D, knapsack, interval, tree), optimization techniques, and practical problem-solving strategies with real LeetCode examples.","authors":["oeid"],"tags":["algorithms","dynamic-programming","optimization","problem-solving","computer-science","knapsack","memoization","tabulation"],"date":"2025-01-31T10:00","draft":false},"sidebar":"changelogSidebar","previous":{"title":"Emoji Usage","permalink":"/docs/definitions/emojis-for-activities"},"next":{"title":"Understanding Graphs: A Complete Mental Model for Network Analysis, Algorithms, and Problem-Solving","permalink":"/docs/mental-models/understanding-data-structs-and-algos/understanding-graphs"}}');var r=i(74848),t=i(28453);const l={slug:"understanding-dynamic-programming",title:"Understanding Dynamic Programming: A Complete Mental Model for Algorithm Optimization and Problem-Solving",description:"A comprehensive guide covering DP fundamentals, problem types (1D, 2D, knapsack, interval, tree), optimization techniques, and practical problem-solving strategies with real LeetCode examples.",authors:["oeid"],tags:["algorithms","dynamic-programming","optimization","problem-solving","computer-science","knapsack","memoization","tabulation"],date:"2025-01-31T10:00",draft:!1},o="Understanding Dynamic Programming: A Complete Mental Model for Algorithm Optimization and Problem-Solving",a={},d=[{value:"Purpose",id:"purpose",level:2},{value:"What is Dynamic Programming?",id:"what-is-dynamic-programming",level:2},{value:"Key Characteristics",id:"key-characteristics",level:3},{value:"Core DP Principles",id:"core-dp-principles",level:2},{value:"1. Optimal Substructure",id:"1-optimal-substructure",level:3},{value:"2. Overlapping Subproblems",id:"2-overlapping-subproblems",level:3},{value:"DP Implementation Approaches",id:"dp-implementation-approaches",level:2},{value:"1. Top-Down (Memoization)",id:"1-top-down-memoization",level:3},{value:"2. Bottom-Up (Tabulation)",id:"2-bottom-up-tabulation",level:3},{value:"Common DP Patterns",id:"common-dp-patterns",level:2},{value:"1. 1D DP (Linear)",id:"1-1d-dp-linear",level:3},{value:"2. 2D DP (Grid)",id:"2-2d-dp-grid",level:3},{value:"3. Knapsack Pattern",id:"3-knapsack-pattern",level:3},{value:"Advanced DP Patterns",id:"advanced-dp-patterns",level:2},{value:"1. Longest Common Subsequence (LCS)",id:"1-longest-common-subsequence-lcs",level:3},{value:"2. Edit Distance",id:"2-edit-distance",level:3},{value:"3. Longest Increasing Subsequence (LIS)",id:"3-longest-increasing-subsequence-lis",level:3},{value:"DP Problem-Solving Framework",id:"dp-problem-solving-framework",level:2},{value:"Step 1: Identify the Problem Type",id:"step-1-identify-the-problem-type",level:3},{value:"Step 2: Define State",id:"step-2-define-state",level:3},{value:"Step 3: Find Recurrence Relation",id:"step-3-find-recurrence-relation",level:3},{value:"Step 4: Implement Solution",id:"step-4-implement-solution",level:3},{value:"Step 5: Optimize Space (if needed)",id:"step-5-optimize-space-if-needed",level:3},{value:"Space Optimization Techniques",id:"space-optimization-techniques",level:2},{value:"1. Rolling Array",id:"1-rolling-array",level:3},{value:"2. 2D to 1D Optimization",id:"2-2d-to-1d-optimization",level:3},{value:"Common DP Mistakes to Avoid",id:"common-dp-mistakes-to-avoid",level:2},{value:"DP Problem Types and When to Use Each Approach",id:"dp-problem-types-and-when-to-use-each-approach",level:2},{value:"1. 1D DP Problems",id:"1-1d-dp-problems",level:3},{value:"2. 2D DP Problems",id:"2-2d-dp-problems",level:3},{value:"3. Knapsack Problems",id:"3-knapsack-problems",level:3},{value:"4. Interval DP Problems",id:"4-interval-dp-problems",level:3},{value:"5. Tree DP Problems",id:"5-tree-dp-problems",level:3},{value:"DP Problem-Solving Framework",id:"dp-problem-solving-framework-1",level:2},{value:"Step 1: Identify the Problem Type",id:"step-1-identify-the-problem-type-1",level:3},{value:"Step 2: Define State and Transitions",id:"step-2-define-state-and-transitions",level:3},{value:"Step 3: Choose Implementation Approach",id:"step-3-choose-implementation-approach",level:3},{value:"Step 4: Optimize and Validate",id:"step-4-optimize-and-validate",level:3},{value:"Key Distinctions: Dynamic Programming vs Other Approaches",id:"key-distinctions-dynamic-programming-vs-other-approaches",level:2},{value:"Dynamic Programming vs Recursion",id:"dynamic-programming-vs-recursion",level:3},{value:"Key Differences",id:"key-differences",level:4},{value:"Visual Comparison",id:"visual-comparison",level:4},{value:"When to Use Each",id:"when-to-use-each",level:4},{value:"Dynamic Programming vs Greedy Algorithms",id:"dynamic-programming-vs-greedy-algorithms",level:3},{value:"Key Differences",id:"key-differences-1",level:4},{value:"Example: Coin Change Problem",id:"example-coin-change-problem",level:4},{value:"When to Use Each",id:"when-to-use-each-1",level:4},{value:"Dynamic Programming vs Divide and Conquer",id:"dynamic-programming-vs-divide-and-conquer",level:3},{value:"Key Differences",id:"key-differences-2",level:4},{value:"Visual Comparison",id:"visual-comparison-1",level:4},{value:"When to Use Each",id:"when-to-use-each-2",level:4},{value:"DP vs Other Approaches",id:"dp-vs-other-approaches",level:2},{value:"Action Items",id:"action-items",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"understanding-dynamic-programming-a-complete-mental-model-for-algorithm-optimization-and-problem-solving",children:"Understanding Dynamic Programming: A Complete Mental Model for Algorithm Optimization and Problem-Solving"})}),"\n",(0,r.jsx)(n.p,{children:"A comprehensive guide covering DP fundamentals, problem types (1D, 2D, knapsack, interval, tree), optimization techniques, and practical problem-solving strategies with real LeetCode examples."}),"\n",(0,r.jsx)(n.h2,{id:"purpose",children:"Purpose"}),"\n",(0,r.jsx)(n.p,{children:"This guide was created to address four critical needs:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"I need to understand DP fundamentals"}),": Learn the core principles, characteristics, and when to apply dynamic programming"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"I need to master DP patterns"}),": Recognize and implement common DP patterns like knapsack, LCS, and edit distance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"I need to optimize DP solutions"}),": Transform recursive solutions into efficient bottom-up and top-down approaches"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"I need to solve DP problems confidently"}),": Tackle complex optimization problems using systematic DP thinking"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The goal is to transform confusion about dynamic programming into clear, systematic problem-solving skills through structured learning and pattern recognition."}),"\n",(0,r.jsx)(n.h2,{id:"what-is-dynamic-programming",children:"What is Dynamic Programming?"}),"\n",(0,r.jsx)(n.p,{children:"Dynamic Programming (DP) is an algorithmic technique for solving optimization problems by breaking them down into simpler subproblems and storing the results to avoid redundant calculations."}),"\n",(0,r.jsx)(n.h3,{id:"key-characteristics",children:"Key Characteristics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Optimal Substructure"}),": Optimal solution contains optimal solutions to subproblems"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Overlapping Subproblems"}),": Same subproblems are solved multiple times"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Memoization"}),": Store results of subproblems to avoid recalculation"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Bottom-up or Top-down"}),": Two main approaches to implementation"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"core-dp-principles",children:"Core DP Principles"}),"\n",(0,r.jsx)(n.h3,{id:"1-optimal-substructure",children:"1. Optimal Substructure"}),"\n",(0,r.jsx)(n.p,{children:"The optimal solution to a problem contains optimal solutions to its subproblems."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": In the Fibonacci sequence, ",(0,r.jsx)(n.code,{children:"fib(n) = fib(n-1) + fib(n-2)"})]}),"\n",(0,r.jsx)(n.h3,{id:"2-overlapping-subproblems",children:"2. Overlapping Subproblems"}),"\n",(0,r.jsx)(n.p,{children:"The same subproblems are solved multiple times in a recursive approach."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": Computing ",(0,r.jsx)(n.code,{children:"fib(5)"})," requires ",(0,r.jsx)(n.code,{children:"fib(3)"})," multiple times:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"fib(5)\n\u251c\u2500\u2500 fib(4)\n\u2502   \u251c\u2500\u2500 fib(3) \u2190 computed multiple times\n\u2502   \u2514\u2500\u2500 fib(2)\n\u2514\u2500\u2500 fib(3) \u2190 computed multiple times\n    \u251c\u2500\u2500 fib(2)\n    \u2514\u2500\u2500 fib(1)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"dp-implementation-approaches",children:"DP Implementation Approaches"}),"\n",(0,r.jsx)(n.h3,{id:"1-top-down-memoization",children:"1. Top-Down (Memoization)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def fibonacci_memo(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    \n    memo[n] = fibonacci_memo(n-1, memo) + fibonacci_memo(n-2, memo)\n    return memo[n]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-bottom-up-tabulation",children:"2. Bottom-Up (Tabulation)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def fibonacci_tabulation(n):\n    if n <= 1:\n        return n\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"common-dp-patterns",children:"Common DP Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"1-1d-dp-linear",children:"1. 1D DP (Linear)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def house_robber(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \n    return dp[-1]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-2d-dp-grid",children:"2. 2D DP (Grid)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def unique_paths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[m-1][n-1]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-knapsack-pattern",children:"3. Knapsack Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def knapsack_01(weights, values, capacity):\n    n = len(weights)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if weights[i-1] <= w:\n                dp[i][w] = max(\n                    values[i-1] + dp[i-1][w - weights[i-1]],\n                    dp[i-1][w]\n                )\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    return dp[n][capacity]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-dp-patterns",children:"Advanced DP Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"1-longest-common-subsequence-lcs",children:"1. Longest Common Subsequence (LCS)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def longest_common_subsequence(text1, text2):\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i-1] == text2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[m][n]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-edit-distance",children:"2. Edit Distance"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def edit_distance(word1, word2):\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Initialize base cases\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i-1][j],    # delete\n                    dp[i][j-1],    # insert\n                    dp[i-1][j-1]   # replace\n                )\n    \n    return dp[m][n]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-longest-increasing-subsequence-lis",children:"3. Longest Increasing Subsequence (LIS)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def length_of_lis(nums):\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"dp-problem-solving-framework",children:"DP Problem-Solving Framework"}),"\n",(0,r.jsx)(n.h3,{id:"step-1-identify-the-problem-type",children:"Step 1: Identify the Problem Type"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Optimization problem?"}),"\n",(0,r.jsx)(n.li,{children:"Can be broken into subproblems?"}),"\n",(0,r.jsx)(n.li,{children:"Optimal substructure?"}),"\n",(0,r.jsx)(n.li,{children:"Overlapping subproblems?"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"step-2-define-state",children:"Step 2: Define State"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["What does ",(0,r.jsx)(n.code,{children:"dp[i]"})," represent?"]}),"\n",(0,r.jsx)(n.li,{children:"What are the dimensions?"}),"\n",(0,r.jsx)(n.li,{children:"What are the base cases?"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"step-3-find-recurrence-relation",children:"Step 3: Find Recurrence Relation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["How does ",(0,r.jsx)(n.code,{children:"dp[i]"})," relate to previous states?"]}),"\n",(0,r.jsx)(n.li,{children:"What are the transitions?"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"step-4-implement-solution",children:"Step 4: Implement Solution"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Choose top-down or bottom-up"}),"\n",(0,r.jsx)(n.li,{children:"Handle base cases"}),"\n",(0,r.jsx)(n.li,{children:"Implement transitions"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"step-5-optimize-space-if-needed",children:"Step 5: Optimize Space (if needed)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reduce dimensions"}),"\n",(0,r.jsx)(n.li,{children:"Use rolling arrays"}),"\n",(0,r.jsx)(n.li,{children:"Space optimization techniques"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"space-optimization-techniques",children:"Space Optimization Techniques"}),"\n",(0,r.jsx)(n.h3,{id:"1-rolling-array",children:"1. Rolling Array"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def fibonacci_optimized(n):\n    if n <= 1:\n        return n\n    \n    prev2, prev1 = 0, 1\n    \n    for i in range(2, n + 1):\n        current = prev1 + prev2\n        prev2, prev1 = prev1, current\n    \n    return prev1\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-2d-to-1d-optimization",children:"2. 2D to 1D Optimization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def knapsack_optimized(weights, values, capacity):\n    dp = [0] * (capacity + 1)\n    \n    for i in range(len(weights)):\n        for w in range(capacity, weights[i] - 1, -1):\n            dp[w] = max(dp[w], values[i] + dp[w - weights[i]])\n    \n    return dp[capacity]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"common-dp-mistakes-to-avoid",children:"Common DP Mistakes to Avoid"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Not identifying overlapping subproblems"})," - leads to exponential time complexity"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Incorrect state definition"})," - makes recurrence relation impossible"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Missing base cases"})," - causes incorrect results or infinite loops"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Wrong transition logic"})," - leads to incorrect optimal solutions"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Not optimizing space"})," - uses unnecessary memory"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"dp-problem-types-and-when-to-use-each-approach",children:"DP Problem Types and When to Use Each Approach"}),"\n",(0,r.jsx)(n.h3,{id:"1-1d-dp-problems",children:"1. 1D DP Problems"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Characteristics"}),": Single dimension state, linear progression\n",(0,r.jsx)(n.strong,{children:"Examples"}),": Fibonacci, Climbing Stairs, House Robber\n",(0,r.jsx)(n.strong,{children:"When to use"}),": Sequential problems, single variable optimization"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Pattern: dp[i] = f(dp[i-1], dp[i-2], ...)\ndef house_robber(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \n    return dp[-1]\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/climbing-stairs/",children:"Climbing Stairs"})," - Basic 1D DP"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/house-robber/",children:"House Robber"})," - Optimization with constraints"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/decode-ways/",children:"Decode Ways"})," - String processing with DP"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-2d-dp-problems",children:"2. 2D DP Problems"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Characteristics"}),": Two dimensions, grid or matrix problems\n",(0,r.jsx)(n.strong,{children:"Examples"}),": Unique Paths, Longest Common Subsequence, Edit Distance\n",(0,r.jsx)(n.strong,{children:"When to use"}),": Grid problems, string matching, matrix operations"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Pattern: dp[i][j] = f(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\ndef unique_paths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[m-1][n-1]\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/unique-paths/",children:"Unique Paths"})," - Grid traversal"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/longest-common-subsequence/",children:"Longest Common Subsequence"})," - String matching"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/edit-distance/",children:"Edit Distance"})," - String transformation"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-knapsack-problems",children:"3. Knapsack Problems"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Characteristics"}),": Selection with constraints, optimization\n",(0,r.jsx)(n.strong,{children:"Examples"}),": 0/1 Knapsack, Unbounded Knapsack, Target Sum\n",(0,r.jsx)(n.strong,{children:"When to use"}),": Resource allocation, selection problems, optimization with constraints"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Pattern: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value)\ndef knapsack_01(weights, values, capacity):\n    n = len(weights)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if weights[i-1] <= w:\n                dp[i][w] = max(\n                    values[i-1] + dp[i-1][w - weights[i-1]],\n                    dp[i-1][w]\n                )\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    return dp[n][capacity]\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/target-sum/",children:"Target Sum"})," - 0/1 Knapsack variant"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/coin-change/",children:"Coin Change"})," - Unbounded knapsack"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/partition-equal-subset-sum/",children:"Partition Equal Subset Sum"})," - Subset sum"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-interval-dp-problems",children:"4. Interval DP Problems"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Characteristics"}),": Range-based problems, optimal substructure in intervals\n",(0,r.jsx)(n.strong,{children:"Examples"}),": Matrix Chain Multiplication, Palindrome Partitioning\n",(0,r.jsx)(n.strong,{children:"When to use"}),": Range queries, interval optimization, matrix operations"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Pattern: dp[i][j] = min/max over all k in [i,j] of dp[i][k] + dp[k+1][j] + cost\ndef matrix_chain_multiplication(dims):\n    n = len(dims) - 1\n    dp = [[0] * n for _ in range(n)]\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = float('inf')\n            for k in range(i, j):\n                cost = dims[i] * dims[k+1] * dims[j+1]\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + cost)\n    \n    return dp[0][n-1]\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/palindrome-partitioning-ii/",children:"Palindrome Partitioning II"})," - Interval optimization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/burst-balloons/",children:"Burst Balloons"})," - Range DP"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-cost-to-merge-stones/",children:"Minimum Cost to Merge Stones"})," - Interval merging"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"5-tree-dp-problems",children:"5. Tree DP Problems"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Characteristics"}),": Tree traversal with state, bottom-up computation\n",(0,r.jsx)(n.strong,{children:"Examples"}),": Binary Tree Maximum Path Sum, House Robber III\n",(0,r.jsx)(n.strong,{children:"When to use"}),": Tree problems, hierarchical optimization, recursive structures"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Pattern: Return multiple values from each subtree\ndef max_path_sum(root):\n    def dfs(node):\n        if not node:\n            return 0\n        \n        left = max(0, dfs(node.left))\n        right = max(0, dfs(node.right))\n        \n        # Update global maximum\n        nonlocal max_sum\n        max_sum = max(max_sum, node.val + left + right)\n        \n        # Return maximum path ending at this node\n        return node.val + max(left, right)\n    \n    max_sum = float('-inf')\n    dfs(root)\n    return max_sum\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-maximum-path-sum/",children:"Binary Tree Maximum Path Sum"})," - Tree DP"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/house-robber-iii/",children:"House Robber III"})," - Tree optimization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/longest-univalue-path/",children:"Longest Univalue Path"})," - Tree path optimization"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"dp-problem-solving-framework-1",children:"DP Problem-Solving Framework"}),"\n",(0,r.jsx)(n.h3,{id:"step-1-identify-the-problem-type-1",children:"Step 1: Identify the Problem Type"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimization problem?"})," \u2192 Likely DP"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Overlapping subproblems?"})," \u2192 Memoization needed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimal substructure?"})," \u2192 DP applicable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Decision at each step?"})," \u2192 State definition"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"step-2-define-state-and-transitions",children:"Step 2: Define State and Transitions"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"What does dp[i] represent?"})," \u2192 State definition"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"How does dp[i] relate to previous states?"})," \u2192 Transition relation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"What are the base cases?"})," \u2192 Initial conditions"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"step-3-choose-implementation-approach",children:"Step 3: Choose Implementation Approach"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Top-down (Memoization)"}),": Natural recursive thinking"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bottom-up (Tabulation)"}),": Iterative, space-efficient"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space optimization"}),": Rolling arrays, state compression"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"step-4-optimize-and-validate",children:"Step 4: Optimize and Validate"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time complexity"}),": Ensure polynomial time"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space complexity"}),": Optimize if needed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Edge cases"}),": Handle boundary conditions"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"key-distinctions-dynamic-programming-vs-other-approaches",children:"Key Distinctions: Dynamic Programming vs Other Approaches"}),"\n",(0,r.jsx)(n.p,{children:"Understanding the fundamental differences between DP and other algorithmic approaches is crucial for choosing the right solution strategy."}),"\n",(0,r.jsx)(n.h3,{id:"dynamic-programming-vs-recursion",children:"Dynamic Programming vs Recursion"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"\u274c Common Misconception"}),': "DP is just fancy recursion"']}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"\u2705 Reality"}),": DP is recursion with memoization, but they serve different purposes"]}),"\n",(0,r.jsx)(n.h4,{id:"key-differences",children:"Key Differences"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Aspect"}),(0,r.jsx)(n.th,{children:"Dynamic Programming"}),(0,r.jsx)(n.th,{children:"Pure Recursion"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Overlapping Subproblems"})}),(0,r.jsx)(n.td,{children:"\u2705 Identifies and stores results"}),(0,r.jsx)(n.td,{children:"\u274c Recalculates same subproblems"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Time Complexity"})}),(0,r.jsx)(n.td,{children:"O(n) with memoization"}),(0,r.jsx)(n.td,{children:"O(2^n) exponential"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Space Complexity"})}),(0,r.jsx)(n.td,{children:"O(n) for memoization"}),(0,r.jsx)(n.td,{children:"O(n) for call stack"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Optimal Substructure"})}),(0,r.jsx)(n.td,{children:"\u2705 Required"}),(0,r.jsx)(n.td,{children:"\u2705 Required"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Memory Usage"})}),(0,r.jsx)(n.td,{children:"Higher (memoization table)"}),(0,r.jsx)(n.td,{children:"Lower (just call stack)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Implementation"})}),(0,r.jsx)(n.td,{children:"More complex"}),(0,r.jsx)(n.td,{children:"Simpler to write"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Performance"})}),(0,r.jsx)(n.td,{children:"Much faster"}),(0,r.jsx)(n.td,{children:"Can be very slow"})]})]})]}),"\n",(0,r.jsx)(n.h4,{id:"visual-comparison",children:"Visual Comparison"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pure Recursion (Fibonacci)"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"fib(5)\n\u251c\u2500\u2500 fib(4)\n\u2502   \u251c\u2500\u2500 fib(3) \u2190 calculated multiple times\n\u2502   \u2514\u2500\u2500 fib(2)\n\u2514\u2500\u2500 fib(3) \u2190 calculated multiple times\n    \u251c\u2500\u2500 fib(2)\n    \u2514\u2500\u2500 fib(1)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time"}),": O(2^n) - exponential"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space"}),": O(n) - call stack only"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Redundancy"}),": High - same calculations repeated"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Dynamic Programming (Memoized)"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"fib(5) \u2192 memo[5] = 5\n\u251c\u2500\u2500 fib(4) \u2192 memo[4] = 3\n\u2502   \u251c\u2500\u2500 fib(3) \u2192 memo[3] = 2 (stored)\n\u2502   \u2514\u2500\u2500 fib(2) \u2192 memo[2] = 1 (stored)\n\u2514\u2500\u2500 fib(3) \u2192 memo[3] = 2 (retrieved from memo)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time"}),": O(n) - linear"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space"}),": O(n) - memoization table"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Redundancy"}),": None - each calculation done once"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"when-to-use-each",children:"When to Use Each"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Dynamic Programming when"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Overlapping subproblems exist"}),"\n",(0,r.jsx)(n.li,{children:"Optimal substructure present"}),"\n",(0,r.jsx)(n.li,{children:"Performance is critical"}),"\n",(0,r.jsx)(n.li,{children:"Problem size is large"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Pure Recursion when"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No overlapping subproblems"}),"\n",(0,r.jsx)(n.li,{children:"Simple, small problems"}),"\n",(0,r.jsx)(n.li,{children:"Code clarity is priority"}),"\n",(0,r.jsx)(n.li,{children:"Performance is not critical"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DP Problems"}),": ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/climbing-stairs/",children:"Climbing Stairs"})," - Overlapping subproblems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pure Recursion"}),": ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-inorder-traversal/",children:"Binary Tree Traversal"})," - No overlapping"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"dynamic-programming-vs-greedy-algorithms",children:"Dynamic Programming vs Greedy Algorithms"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"\u274c Common Misconception"}),': "DP and greedy are the same - both make optimal choices"']}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"\u2705 Reality"}),": Greedy makes locally optimal choices, DP considers all possibilities"]}),"\n",(0,r.jsx)(n.h4,{id:"key-differences-1",children:"Key Differences"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Aspect"}),(0,r.jsx)(n.th,{children:"Dynamic Programming"}),(0,r.jsx)(n.th,{children:"Greedy Algorithms"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Decision Making"})}),(0,r.jsx)(n.td,{children:"Considers all possibilities"}),(0,r.jsx)(n.td,{children:"Makes locally optimal choice"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Optimality"})}),(0,r.jsx)(n.td,{children:"Guaranteed global optimum"}),(0,r.jsx)(n.td,{children:"May not be globally optimal"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Backtracking"})}),(0,r.jsx)(n.td,{children:"Can reconsider decisions"}),(0,r.jsx)(n.td,{children:"No backtracking"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Time Complexity"})}),(0,r.jsx)(n.td,{children:"Usually O(n\xb2) or O(n\xb3)"}),(0,r.jsx)(n.td,{children:"Usually O(n log n) or O(n)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Space Complexity"})}),(0,r.jsx)(n.td,{children:"O(n) or O(n\xb2)"}),(0,r.jsx)(n.td,{children:"Usually O(1) or O(n)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Problem Types"})}),(0,r.jsx)(n.td,{children:"Optimization with constraints"}),(0,r.jsx)(n.td,{children:"Optimization without constraints"})]})]})]}),"\n",(0,r.jsx)(n.h4,{id:"example-coin-change-problem",children:"Example: Coin Change Problem"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Greedy Approach"})," (doesn't always work):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def coin_change_greedy(coins, amount):\n    coins.sort(reverse=True)  # Use largest coins first\n    count = 0\n    for coin in coins:\n        count += amount // coin\n        amount %= coin\n    return count if amount == 0 else -1\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Fails for coins [1, 3, 4] and amount 6"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Greedy"}),": 4 + 1 + 1 = 3 coins"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimal"}),": 3 + 3 = 2 coins"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Dynamic Programming Approach"})," (always works):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def coin_change_dp(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1\n"})}),"\n",(0,r.jsx)(n.h4,{id:"when-to-use-each-1",children:"When to Use Each"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Dynamic Programming when"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Need guaranteed optimal solution"}),"\n",(0,r.jsx)(n.li,{children:"Problem has overlapping subproblems"}),"\n",(0,r.jsx)(n.li,{children:"Constraints are complex"}),"\n",(0,r.jsx)(n.li,{children:"All possibilities must be considered"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Greedy when"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Locally optimal choice leads to global optimum"}),"\n",(0,r.jsx)(n.li,{children:"Problem has greedy choice property"}),"\n",(0,r.jsx)(n.li,{children:"Simple, fast solution needed"}),"\n",(0,r.jsx)(n.li,{children:"Optimality can be proven"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DP Problems"}),": ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/coin-change/",children:"Coin Change"})," - Need optimal solution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Greedy Problems"}),": ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/jump-game/",children:"Jump Game"})," - Greedy choice works"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"dynamic-programming-vs-divide-and-conquer",children:"Dynamic Programming vs Divide and Conquer"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"\u274c Common Misconception"}),': "DP and divide-and-conquer are the same - both break problems down"']}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"\u2705 Reality"}),": Both break problems down, but DP has overlapping subproblems, D&C doesn't"]}),"\n",(0,r.jsx)(n.h4,{id:"key-differences-2",children:"Key Differences"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Aspect"}),(0,r.jsx)(n.th,{children:"Dynamic Programming"}),(0,r.jsx)(n.th,{children:"Divide and Conquer"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Overlapping Subproblems"})}),(0,r.jsx)(n.td,{children:"\u2705 Yes"}),(0,r.jsx)(n.td,{children:"\u274c No"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Subproblem Independence"})}),(0,r.jsx)(n.td,{children:"\u274c Dependent"}),(0,r.jsx)(n.td,{children:"\u2705 Independent"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Memoization"})}),(0,r.jsx)(n.td,{children:"\u2705 Required"}),(0,r.jsx)(n.td,{children:"\u274c Not needed"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Time Complexity"})}),(0,r.jsx)(n.td,{children:"O(n) with memoization"}),(0,r.jsx)(n.td,{children:"O(n log n) typically"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Examples"})}),(0,r.jsx)(n.td,{children:"Fibonacci, LCS"}),(0,r.jsx)(n.td,{children:"Merge Sort, Quick Sort"})]})]})]}),"\n",(0,r.jsx)(n.h4,{id:"visual-comparison-1",children:"Visual Comparison"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Divide and Conquer (Merge Sort)"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"[8,3,1,6,4,7,2,5]\n\u251c\u2500\u2500 [8,3,1,6] \u2190 independent\n\u2502   \u251c\u2500\u2500 [8,3] \u2190 independent\n\u2502   \u2514\u2500\u2500 [1,6] \u2190 independent\n\u2514\u2500\u2500 [4,7,2,5] \u2190 independent\n    \u251c\u2500\u2500 [4,7] \u2190 independent\n    \u2514\u2500\u2500 [2,5] \u2190 independent\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No overlapping subproblems"}),"\n",(0,r.jsx)(n.li,{children:"Each subproblem is independent"}),"\n",(0,r.jsx)(n.li,{children:"No need to store results"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Dynamic Programming (Fibonacci)"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"fib(5)\n\u251c\u2500\u2500 fib(4) \u2190 overlaps with fib(3)\n\u2502   \u2514\u2500\u2500 fib(3) \u2190 overlaps with fib(3) from right\n\u2514\u2500\u2500 fib(3) \u2190 same as above\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Overlapping subproblems"}),"\n",(0,r.jsx)(n.li,{children:"Results need to be stored"}),"\n",(0,r.jsx)(n.li,{children:"Memoization required"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"when-to-use-each-2",children:"When to Use Each"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Dynamic Programming when"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Overlapping subproblems exist"}),"\n",(0,r.jsx)(n.li,{children:"Optimal substructure present"}),"\n",(0,r.jsx)(n.li,{children:"Need to store intermediate results"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Divide and Conquer when"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No overlapping subproblems"}),"\n",(0,r.jsx)(n.li,{children:"Subproblems are independent"}),"\n",(0,r.jsx)(n.li,{children:"Can solve subproblems separately"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"LeetCode Examples"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DP Problems"}),": ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/longest-common-subsequence/",children:"Longest Common Subsequence"})," - Overlapping subproblems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"D&C Problems"}),": ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/sort-an-array/",children:"Merge Sort"})," - Independent subproblems"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"dp-vs-other-approaches",children:"DP vs Other Approaches"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Approach"}),(0,r.jsx)(n.th,{children:"Time Complexity"}),(0,r.jsx)(n.th,{children:"Space Complexity"}),(0,r.jsx)(n.th,{children:"When to Use"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Brute Force"}),(0,r.jsx)(n.td,{children:"O(2^n)"}),(0,r.jsx)(n.td,{children:"O(n)"}),(0,r.jsx)(n.td,{children:"Small problems"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Memoization"}),(0,r.jsx)(n.td,{children:"O(n)"}),(0,r.jsx)(n.td,{children:"O(n)"}),(0,r.jsx)(n.td,{children:"Top-down thinking"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Tabulation"}),(0,r.jsx)(n.td,{children:"O(n)"}),(0,r.jsx)(n.td,{children:"O(n)"}),(0,r.jsx)(n.td,{children:"Bottom-up approach"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Optimized DP"}),(0,r.jsx)(n.td,{children:"O(n)"}),(0,r.jsx)(n.td,{children:"O(1)"}),(0,r.jsx)(n.td,{children:"Space-constrained"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"action-items",children:"Action Items"}),"\n",(0,r.jsx)(n.p,{children:"This section contains specific action items that readers can take to enhance their understanding or apply the concepts from this post:"}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Implement 5 classic DP problems"}),": Solve Fibonacci, Climbing Stairs, House Robber, Coin Change, and Longest Common Subsequence problems from scratch"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Master the DP problem-solving framework"}),": Practice identifying optimal substructure and overlapping subproblems in 10 different problem types"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Optimize space complexity"}),": Take 3 existing DP solutions and optimize their space complexity using rolling arrays or other techniques"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Build a DP problem classifier"}),": Create a system that can categorize problems into DP patterns (1D, 2D, knapsack, LCS, etc.) based on problem descriptions"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Implementation Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each action item should be specific and measurable"}),"\n",(0,r.jsx)(n.li,{children:"Include expected outcomes or deliverables"}),"\n",(0,r.jsx)(n.li,{children:"Consider different skill levels (beginner, intermediate, advanced)"}),"\n",(0,r.jsx)(n.li,{children:"Provide context for why each action item is valuable"}),"\n"]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsx)("summary",{children:"\ud83e\udd16 AI Metadata (Click to expand)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'# AI METADATA - DO NOT REMOVE OR MODIFY\n# AI_UPDATE_INSTRUCTIONS:\n# This content should be updated when new DP algorithms, problem types, or optimization techniques emerge\n#\n# 1. SCAN_SOURCES: Monitor algorithm textbooks, competitive programming resources, LeetCode DP problems, and DP research papers\n# 2. EXTRACT_DATA: Look for new DP problem types, optimization strategies, space optimization techniques, and real-world applications\n# 3. UPDATE_CONTENT: Add new DP problem types, update algorithm implementations, include new LeetCode problems, expand optimization techniques\n# 4. VERIFY_CHANGES: Ensure all code examples compile and run correctly, verify algorithm complexity claims, test LeetCode links\n# 5. MAINTAIN_FORMAT: Preserve the "I need to..." format in Purpose section, keep action items specific and measurable\n#\n# CONTENT_PATTERNS:\n# - DP problem types: Include characteristics, examples, when to use, LeetCode problems for each type\n# - Algorithm implementations: Always include time/space complexity, both memoization and tabulation approaches\n# - Code examples: Use clear variable names, include comments, provide pattern templates\n# - Problem patterns: Include both theoretical understanding and practical implementation with real examples\n# - Optimization techniques: Cover space optimization, rolling arrays, state compression\n#\n# DATA_SOURCES:\n# - Algorithm textbooks: Introduction to Algorithms (CLRS), Algorithm Design Manual, Competitive Programming Handbook\n# - Competitive programming: Codeforces DP problems, AtCoder DP contests, TopCoder algorithm tutorials\n# - Coding platforms: LeetCode DP problems, HackerRank algorithms, GeeksforGeeks DP section\n# - Research papers: DP optimization techniques, advanced DP patterns, algorithmic improvements\n# - University courses: MIT 6.006, Stanford CS161, Princeton algorithms\n#\n# UPDATE_TRIGGERS:\n# - New DP algorithms published in computer science literature\n# - Changes in competitive programming DP problem patterns\n# - New LeetCode DP problems with different difficulty levels\n# - Performance improvements in DP implementations and space optimization\n# - New real-world applications of dynamic programming (optimization, game theory, economics)\n# - Updates to DP libraries and frameworks\n#\n# FORMATTING_RULES:\n# - Use \u2705 and \u274c for good/bad examples consistently\n# - Include code blocks with proper syntax highlighting (python, markdown)\n# - Maintain table formatting for comparisons and algorithm selection guides\n# - Keep action items in checkbox format with implementation notes\n# - Include LeetCode links with descriptive text\n# - Use pattern templates for different DP problem types\n#\n# UPDATE_FREQUENCY: Monthly review for new LeetCode problems, quarterly review for algorithms, annual review for comprehensive updates\n'})})]})]})}function m(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var s=i(96540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);