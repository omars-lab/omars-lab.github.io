---
slug: 'dfs-vs-bfs'
title: 'ðŸŒ³ DFS vs BFS'
description: 'Learn the key differences between Depth-First Search and Breadth-First Search, and discover when to use each algorithm for optimal problem-solving.'
tags: [dfs, bfs, graph-theory, algorithms, leetcode]
date: 2025-03-07T10:00
draft: true
---

I wanted to consolidate knowledge surrounding BFS vs DFS; thus I made this post.

<!-- truncate -->


# DFS vs BFS: When to Use Each Algorithm for Graph Problems

When solving graph and tree problems, one of the most fundamental decisions you'll make is choosing between Depth-First Search (DFS) and Breadth-First Search (BFS). Understanding when to use each algorithm can be the difference between an elegant solution and a complex workaround.

## The Core Difference

**Depth-First Search (DFS)** explores as far as possible along each branch before backtracking. It's like exploring a maze by always taking the first available path until you hit a dead end.

**Breadth-First Search (BFS)** explores all nodes at the current level before moving to the next level. It's like exploring a maze by checking all paths one step away, then all paths two steps away, and so on.

## When to Use BFS

### âœ… Use BFS when you need:

**1. Shortest Path Problems**
- Finding the shortest path in an unweighted graph
- Minimum steps to reach a target
- Level-by-level exploration

**2. Level-Based Operations**
- Grouping nodes by their distance from the root
- Processing nodes level by level
- Finding nodes at a specific distance

**3. Tree Comparison**
- Comparing two trees structure
- Checking if trees are identical or symmetric

### BFS Examples:

**Level Order Traversal:**
```python
def level_order_traversal(root):
    if not root:
        return []
    
    result = []
    queue = [root]
    
    while queue:
        level_size = len(queue)
        level = []
        
        for _ in range(level_size):
            node = queue.pop(0)
            level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(level)
    
    return result
```

**Tree Comparison:**
```python
def is_same_tree(p, q):
    if not p and not q:
        return True
    if not p or not q:
        return False
    
    queue = [(p, q)]
    
    while queue:
        node1, node2 = queue.pop(0)
        
        if node1.val != node2.val:
            return False
        
        if node1.left and node2.left:
            queue.append((node1.left, node2.left))
        elif node1.left or node2.left:
            return False
        
        if node1.right and node2.right:
            queue.append((node1.right, node2.right))
        elif node1.right or node2.right:
            return False
    
    return True
```

## When to Use DFS

### âœ… Use DFS when you need:

**1. Path Finding**
- Finding any path (not necessarily shortest)
- Exploring all possible paths
- Backtracking problems

**2. Tree/Graph Traversal**
- In-order, pre-order, post-order tree traversal
- Exploring connected components
- Topological sorting

**3. Memory Efficiency**
- When you need to minimize memory usage
- Deep trees where BFS would use too much memory

### DFS Examples:

**Path Sum:**
```python
def has_path_sum(root, target_sum):
    if not root:
        return False
    
    if not root.left and not root.right:
        return root.val == target_sum
    
    return (has_path_sum(root.left, target_sum - root.val) or
            has_path_sum(root.right, target_sum - root.val))
```

**Connected Components:**
```python
def num_islands(grid):
    if not grid:
        return 0
    
    def dfs(i, j):
        if (i < 0 or i >= len(grid) or 
            j < 0 or j >= len(grid[0]) or 
            grid[i][j] != '1'):
            return
        
        grid[i][j] = '0'  # Mark as visited
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)
    
    islands = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(i, j)
                islands += 1
    
    return islands
```

## Decision Framework

### Ask yourself these questions:

1. **Do I need the shortest path?** â†’ BFS
2. **Do I need to process nodes level by level?** â†’ BFS
3. **Am I comparing tree structures?** â†’ BFS
4. **Do I need to explore all possible paths?** â†’ DFS
5. **Is memory usage a concern?** â†’ DFS
6. **Do I need to backtrack?** â†’ DFS

## Real-World Problem: Word Ladder

Let's solve the classic Word Ladder problem to see BFS in action:

**Problem**: Transform one word into another by changing one letter at a time, where each intermediate word must be in a given dictionary.

```python
def word_ladder(begin_word, end_word, word_list):
    if end_word not in word_list:
        return 0
    
    word_set = set(word_list)
    queue = [(begin_word, 1)]
    visited = {begin_word}
    
    while queue:
        word, length = queue.pop(0)
        
        if word == end_word:
            return length
        
        # Try changing each character
        for i in range(len(word)):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                if c == word[i]:
                    continue
                
                new_word = word[:i] + c + word[i+1:]
                
                if new_word in word_set and new_word not in visited:
                    visited.add(new_word)
                    queue.append((new_word, length + 1))
    
    return 0
```

**Why BFS?** Because we need the shortest transformation sequence, and BFS guarantees we'll find the minimum number of steps.

## Performance Considerations

### Time Complexity:
- **BFS**: O(V + E) where V is vertices, E is edges
- **DFS**: O(V + E) where V is vertices, E is edges

### Space Complexity:
- **BFS**: O(V) for the queue (worst case: all nodes at one level)
- **DFS**: O(V) for the recursion stack (worst case: depth of tree)

## Common Mistakes to Avoid

1. **Using DFS for shortest path problems** - BFS is more efficient
2. **Using BFS for backtracking problems** - DFS with recursion is cleaner
3. **Not considering memory constraints** - DFS uses less memory for deep trees
4. **Forgetting to mark visited nodes** - Can lead to infinite loops

## Practice Problems

### BFS Problems:
- [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)
- [Same Tree](https://leetcode.com/problems/same-tree/)
- [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)
- [Word Ladder](https://leetcode.com/problems/word-ladder/)

### DFS Problems:
- [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
- [Path Sum](https://leetcode.com/problems/path-sum/)
- [Number of Islands](https://leetcode.com/problems/number-of-islands/)
- [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)

## Conclusion

The choice between DFS and BFS often comes down to the nature of your problem:

- **BFS** is your go-to for shortest path, level-based operations, and tree comparisons
- **DFS** excels at path exploration, backtracking, and memory-efficient traversal

Remember: both algorithms have the same time complexity, but their space usage patterns and problem-solving approaches differ significantly. Choose the one that best fits your problem's requirements and constraints.

---

*What's your experience with DFS vs BFS? Do you have any tips for recognizing which algorithm to use in interviews?*